{-
   FastAPI

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.2
   FastAPI API version: 0.1.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : Fast.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module Fast.Model where

import Fast.Core
import Fast.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** CodeSnippet
newtype CodeSnippet = CodeSnippet { unCodeSnippet :: Text } deriving (P.Eq, P.Show)

-- ** Context
newtype Context = Context { unContext :: Text } deriving (P.Eq, P.Show)

-- ** Count
newtype Count = Count { unCount :: Int } deriving (P.Eq, P.Show)

-- ** Image
newtype Image = Image { unImage :: FilePath } deriving (P.Eq, P.Show)

-- ** InputString
newtype InputString = InputString { unInputString :: Text } deriving (P.Eq, P.Show)

-- ** InputStringLanguage1
newtype InputStringLanguage1 = InputStringLanguage1 { unInputStringLanguage1 :: Text } deriving (P.Eq, P.Show)

-- ** InputStringLanguage2
newtype InputStringLanguage2 = InputStringLanguage2 { unInputStringLanguage2 :: Text } deriving (P.Eq, P.Show)

-- ** Model
newtype Model = Model { unModel :: E'Model } deriving (P.Eq, P.Show)

-- ** Model10
newtype Model10 = Model10 { unModel10 :: E'Model10 } deriving (P.Eq, P.Show)

-- ** Model11
newtype Model11 = Model11 { unModel11 :: E'Model11 } deriving (P.Eq, P.Show)

-- ** Model12
newtype Model12 = Model12 { unModel12 :: E'Model12 } deriving (P.Eq, P.Show)

-- ** Model13
newtype Model13 = Model13 { unModel13 :: E'Model13 } deriving (P.Eq, P.Show)

-- ** Model14
newtype Model14 = Model14 { unModel14 :: E'Model14 } deriving (P.Eq, P.Show)

-- ** Model15
newtype Model15 = Model15 { unModel15 :: E'Model15 } deriving (P.Eq, P.Show)

-- ** Model16
newtype Model16 = Model16 { unModel16 :: E'Model16 } deriving (P.Eq, P.Show)

-- ** Model17
newtype Model17 = Model17 { unModel17 :: E'Model17 } deriving (P.Eq, P.Show)

-- ** Model18
newtype Model18 = Model18 { unModel18 :: E'Model18 } deriving (P.Eq, P.Show)

-- ** Model19
newtype Model19 = Model19 { unModel19 :: E'Model19 } deriving (P.Eq, P.Show)

-- ** Model2
newtype Model2 = Model2 { unModel2 :: E'Model2 } deriving (P.Eq, P.Show)

-- ** Model20
newtype Model20 = Model20 { unModel20 :: E'Model20 } deriving (P.Eq, P.Show)

-- ** Model21
newtype Model21 = Model21 { unModel21 :: E'Model21 } deriving (P.Eq, P.Show)

-- ** Model22
newtype Model22 = Model22 { unModel22 :: E'Model22 } deriving (P.Eq, P.Show)

-- ** Model23
newtype Model23 = Model23 { unModel23 :: E'Model23 } deriving (P.Eq, P.Show)

-- ** Model24
newtype Model24 = Model24 { unModel24 :: E'Model24 } deriving (P.Eq, P.Show)

-- ** Model3
newtype Model3 = Model3 { unModel3 :: E'Model3 } deriving (P.Eq, P.Show)

-- ** Model4
newtype Model4 = Model4 { unModel4 :: E'Model4 } deriving (P.Eq, P.Show)

-- ** Model5
newtype Model5 = Model5 { unModel5 :: E'Model5 } deriving (P.Eq, P.Show)

-- ** Model6
newtype Model6 = Model6 { unModel6 :: E'Model6 } deriving (P.Eq, P.Show)

-- ** Model7
newtype Model7 = Model7 { unModel7 :: E'Model7 } deriving (P.Eq, P.Show)

-- ** Model8
newtype Model8 = Model8 { unModel8 :: E'Model8 } deriving (P.Eq, P.Show)

-- ** Model9
newtype Model9 = Model9 { unModel9 :: E'Model9 } deriving (P.Eq, P.Show)

-- ** ParamText
newtype ParamText = ParamText { unParamText :: Text } deriving (P.Eq, P.Show)

-- ** Question
newtype Question = Question { unQuestion :: Text } deriving (P.Eq, P.Show)

-- ** Sentence
newtype Sentence = Sentence { unSentence :: Text } deriving (P.Eq, P.Show)

-- ** Sentence1
newtype Sentence1 = Sentence1 { unSentence1 :: Text } deriving (P.Eq, P.Show)

-- ** Sentence2
newtype Sentence2 = Sentence2 { unSentence2 :: Text } deriving (P.Eq, P.Show)

-- ** SourceLanguage
newtype SourceLanguage = SourceLanguage { unSourceLanguage :: Text } deriving (P.Eq, P.Show)

-- ** Word
newtype Word = Word { unWord :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** BodyApplyImageImageBackgroundRemovalPost
-- | BodyApplyImageImageBackgroundRemovalPost
-- Body_apply_image_image_background_removal__post
-- 
data BodyApplyImageImageBackgroundRemovalPost = BodyApplyImageImageBackgroundRemovalPost
  { bodyApplyImageImageBackgroundRemovalPostImage :: !(FilePath) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BodyApplyImageImageBackgroundRemovalPost
instance A.FromJSON BodyApplyImageImageBackgroundRemovalPost where
  parseJSON = A.withObject "BodyApplyImageImageBackgroundRemovalPost" $ \o ->
    BodyApplyImageImageBackgroundRemovalPost
      <$> (o .:  "image")

-- | ToJSON BodyApplyImageImageBackgroundRemovalPost
instance A.ToJSON BodyApplyImageImageBackgroundRemovalPost where
  toJSON BodyApplyImageImageBackgroundRemovalPost {..} =
   _omitNulls
      [ "image" .= bodyApplyImageImageBackgroundRemovalPostImage
      ]


-- | Construct a value of type 'BodyApplyImageImageBackgroundRemovalPost' (by applying it's required fields, if any)
mkBodyApplyImageImageBackgroundRemovalPost
  :: FilePath -- ^ 'bodyApplyImageImageBackgroundRemovalPostImage' 
  -> BodyApplyImageImageBackgroundRemovalPost
mkBodyApplyImageImageBackgroundRemovalPost bodyApplyImageImageBackgroundRemovalPostImage =
  BodyApplyImageImageBackgroundRemovalPost
  { bodyApplyImageImageBackgroundRemovalPostImage
  }

-- ** BodyApplyImageImageColorizationPost
-- | BodyApplyImageImageColorizationPost
-- Body_apply_image_image_colorization__post
-- 
data BodyApplyImageImageColorizationPost = BodyApplyImageImageColorizationPost
  { bodyApplyImageImageColorizationPostImage :: !(FilePath) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BodyApplyImageImageColorizationPost
instance A.FromJSON BodyApplyImageImageColorizationPost where
  parseJSON = A.withObject "BodyApplyImageImageColorizationPost" $ \o ->
    BodyApplyImageImageColorizationPost
      <$> (o .:  "image")

-- | ToJSON BodyApplyImageImageColorizationPost
instance A.ToJSON BodyApplyImageImageColorizationPost where
  toJSON BodyApplyImageImageColorizationPost {..} =
   _omitNulls
      [ "image" .= bodyApplyImageImageColorizationPostImage
      ]


-- | Construct a value of type 'BodyApplyImageImageColorizationPost' (by applying it's required fields, if any)
mkBodyApplyImageImageColorizationPost
  :: FilePath -- ^ 'bodyApplyImageImageColorizationPostImage' 
  -> BodyApplyImageImageColorizationPost
mkBodyApplyImageImageColorizationPost bodyApplyImageImageColorizationPostImage =
  BodyApplyImageImageColorizationPost
  { bodyApplyImageImageColorizationPostImage
  }

-- ** BodyApplyImageImageFaceBluringPost
-- | BodyApplyImageImageFaceBluringPost
-- Body_apply_image_image_face_bluring__post
-- 
data BodyApplyImageImageFaceBluringPost = BodyApplyImageImageFaceBluringPost
  { bodyApplyImageImageFaceBluringPostImage :: !(FilePath) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BodyApplyImageImageFaceBluringPost
instance A.FromJSON BodyApplyImageImageFaceBluringPost where
  parseJSON = A.withObject "BodyApplyImageImageFaceBluringPost" $ \o ->
    BodyApplyImageImageFaceBluringPost
      <$> (o .:  "image")

-- | ToJSON BodyApplyImageImageFaceBluringPost
instance A.ToJSON BodyApplyImageImageFaceBluringPost where
  toJSON BodyApplyImageImageFaceBluringPost {..} =
   _omitNulls
      [ "image" .= bodyApplyImageImageFaceBluringPostImage
      ]


-- | Construct a value of type 'BodyApplyImageImageFaceBluringPost' (by applying it's required fields, if any)
mkBodyApplyImageImageFaceBluringPost
  :: FilePath -- ^ 'bodyApplyImageImageFaceBluringPostImage' 
  -> BodyApplyImageImageFaceBluringPost
mkBodyApplyImageImageFaceBluringPost bodyApplyImageImageFaceBluringPostImage =
  BodyApplyImageImageFaceBluringPost
  { bodyApplyImageImageFaceBluringPostImage
  }

-- ** BodyApplyImageImageSuperResolutionPost
-- | BodyApplyImageImageSuperResolutionPost
-- Body_apply_image_image_super_resolution__post
-- 
data BodyApplyImageImageSuperResolutionPost = BodyApplyImageImageSuperResolutionPost
  { bodyApplyImageImageSuperResolutionPostImage :: !(FilePath) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BodyApplyImageImageSuperResolutionPost
instance A.FromJSON BodyApplyImageImageSuperResolutionPost where
  parseJSON = A.withObject "BodyApplyImageImageSuperResolutionPost" $ \o ->
    BodyApplyImageImageSuperResolutionPost
      <$> (o .:  "image")

-- | ToJSON BodyApplyImageImageSuperResolutionPost
instance A.ToJSON BodyApplyImageImageSuperResolutionPost where
  toJSON BodyApplyImageImageSuperResolutionPost {..} =
   _omitNulls
      [ "image" .= bodyApplyImageImageSuperResolutionPostImage
      ]


-- | Construct a value of type 'BodyApplyImageImageSuperResolutionPost' (by applying it's required fields, if any)
mkBodyApplyImageImageSuperResolutionPost
  :: FilePath -- ^ 'bodyApplyImageImageSuperResolutionPostImage' 
  -> BodyApplyImageImageSuperResolutionPost
mkBodyApplyImageImageSuperResolutionPost bodyApplyImageImageSuperResolutionPostImage =
  BodyApplyImageImageSuperResolutionPost
  { bodyApplyImageImageSuperResolutionPostImage
  }

-- ** BodyApplyImageImageUncolorizationPost
-- | BodyApplyImageImageUncolorizationPost
-- Body_apply_image_image_uncolorization__post
-- 
data BodyApplyImageImageUncolorizationPost = BodyApplyImageImageUncolorizationPost
  { bodyApplyImageImageUncolorizationPostImage :: !(FilePath) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BodyApplyImageImageUncolorizationPost
instance A.FromJSON BodyApplyImageImageUncolorizationPost where
  parseJSON = A.withObject "BodyApplyImageImageUncolorizationPost" $ \o ->
    BodyApplyImageImageUncolorizationPost
      <$> (o .:  "image")

-- | ToJSON BodyApplyImageImageUncolorizationPost
instance A.ToJSON BodyApplyImageImageUncolorizationPost where
  toJSON BodyApplyImageImageUncolorizationPost {..} =
   _omitNulls
      [ "image" .= bodyApplyImageImageUncolorizationPostImage
      ]


-- | Construct a value of type 'BodyApplyImageImageUncolorizationPost' (by applying it's required fields, if any)
mkBodyApplyImageImageUncolorizationPost
  :: FilePath -- ^ 'bodyApplyImageImageUncolorizationPostImage' 
  -> BodyApplyImageImageUncolorizationPost
mkBodyApplyImageImageUncolorizationPost bodyApplyImageImageUncolorizationPostImage =
  BodyApplyImageImageUncolorizationPost
  { bodyApplyImageImageUncolorizationPostImage
  }

-- ** BodyApplyImageTextAsciifyPost
-- | BodyApplyImageTextAsciifyPost
-- Body_apply_image_text_asciify__post
-- 
data BodyApplyImageTextAsciifyPost = BodyApplyImageTextAsciifyPost
  { bodyApplyImageTextAsciifyPostImage :: !(FilePath) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BodyApplyImageTextAsciifyPost
instance A.FromJSON BodyApplyImageTextAsciifyPost where
  parseJSON = A.withObject "BodyApplyImageTextAsciifyPost" $ \o ->
    BodyApplyImageTextAsciifyPost
      <$> (o .:  "image")

-- | ToJSON BodyApplyImageTextAsciifyPost
instance A.ToJSON BodyApplyImageTextAsciifyPost where
  toJSON BodyApplyImageTextAsciifyPost {..} =
   _omitNulls
      [ "image" .= bodyApplyImageTextAsciifyPostImage
      ]


-- | Construct a value of type 'BodyApplyImageTextAsciifyPost' (by applying it's required fields, if any)
mkBodyApplyImageTextAsciifyPost
  :: FilePath -- ^ 'bodyApplyImageTextAsciifyPostImage' 
  -> BodyApplyImageTextAsciifyPost
mkBodyApplyImageTextAsciifyPost bodyApplyImageTextAsciifyPostImage =
  BodyApplyImageTextAsciifyPost
  { bodyApplyImageTextAsciifyPostImage
  }

-- ** BodyApplyImageTextOcrPost
-- | BodyApplyImageTextOcrPost
-- Body_apply_image_text_ocr__post
-- 
data BodyApplyImageTextOcrPost = BodyApplyImageTextOcrPost
  { bodyApplyImageTextOcrPostImage :: !(FilePath) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BodyApplyImageTextOcrPost
instance A.FromJSON BodyApplyImageTextOcrPost where
  parseJSON = A.withObject "BodyApplyImageTextOcrPost" $ \o ->
    BodyApplyImageTextOcrPost
      <$> (o .:  "image")

-- | ToJSON BodyApplyImageTextOcrPost
instance A.ToJSON BodyApplyImageTextOcrPost where
  toJSON BodyApplyImageTextOcrPost {..} =
   _omitNulls
      [ "image" .= bodyApplyImageTextOcrPostImage
      ]


-- | Construct a value of type 'BodyApplyImageTextOcrPost' (by applying it's required fields, if any)
mkBodyApplyImageTextOcrPost
  :: FilePath -- ^ 'bodyApplyImageTextOcrPostImage' 
  -> BodyApplyImageTextOcrPost
mkBodyApplyImageTextOcrPost bodyApplyImageTextOcrPostImage =
  BodyApplyImageTextOcrPost
  { bodyApplyImageTextOcrPostImage
  }

-- ** HTTPValidationError
-- | HTTPValidationError
-- HTTPValidationError
-- 
data HTTPValidationError = HTTPValidationError
  { hTTPValidationErrorDetail :: !(Maybe [ValidationError]) -- ^ "detail"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HTTPValidationError
instance A.FromJSON HTTPValidationError where
  parseJSON = A.withObject "HTTPValidationError" $ \o ->
    HTTPValidationError
      <$> (o .:? "detail")

-- | ToJSON HTTPValidationError
instance A.ToJSON HTTPValidationError where
  toJSON HTTPValidationError {..} =
   _omitNulls
      [ "detail" .= hTTPValidationErrorDetail
      ]


-- | Construct a value of type 'HTTPValidationError' (by applying it's required fields, if any)
mkHTTPValidationError
  :: HTTPValidationError
mkHTTPValidationError =
  HTTPValidationError
  { hTTPValidationErrorDetail = Nothing
  }

-- ** ValidationError
-- | ValidationError
-- ValidationError
-- 
data ValidationError = ValidationError
  { validationErrorLoc :: !([Text]) -- ^ /Required/ "loc"
  , validationErrorMsg :: !(Text) -- ^ /Required/ "msg"
  , validationErrorType :: !(Text) -- ^ /Required/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ValidationError
instance A.FromJSON ValidationError where
  parseJSON = A.withObject "ValidationError" $ \o ->
    ValidationError
      <$> (o .:  "loc")
      <*> (o .:  "msg")
      <*> (o .:  "type")

-- | ToJSON ValidationError
instance A.ToJSON ValidationError where
  toJSON ValidationError {..} =
   _omitNulls
      [ "loc" .= validationErrorLoc
      , "msg" .= validationErrorMsg
      , "type" .= validationErrorType
      ]


-- | Construct a value of type 'ValidationError' (by applying it's required fields, if any)
mkValidationError
  :: [Text] -- ^ 'validationErrorLoc' 
  -> Text -- ^ 'validationErrorMsg' 
  -> Text -- ^ 'validationErrorType' 
  -> ValidationError
mkValidationError validationErrorLoc validationErrorMsg validationErrorType =
  ValidationError
  { validationErrorLoc
  , validationErrorMsg
  , validationErrorType
  }


-- * Enums


-- ** E'Model

-- | Enum of 'Text'
data E'Model
  = E'Model'Mobilenet -- ^ @"mobilenet"@
  | E'Model'Xception -- ^ @"xception"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model where toJSON = A.toJSON . fromE'Model
instance A.FromJSON E'Model where parseJSON o = P.either P.fail (pure . P.id) . toE'Model =<< A.parseJSON o
instance WH.ToHttpApiData E'Model where toQueryParam = WH.toQueryParam . fromE'Model
instance WH.FromHttpApiData E'Model where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model
instance MimeRender MimeMultipartFormData E'Model where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model' enum
fromE'Model :: E'Model -> Text
fromE'Model = \case
  E'Model'Mobilenet -> "mobilenet"
  E'Model'Xception -> "xception"

-- | parse 'E'Model' enum
toE'Model :: Text -> P.Either String E'Model
toE'Model = \case
  "mobilenet" -> P.Right E'Model'Mobilenet
  "xception" -> P.Right E'Model'Xception
  s -> P.Left $ "toE'Model: enum parse failure: " P.++ P.show s


-- ** E'Model10

-- | Enum of 'Text'
data E'Model10
  = E'Model10'Dbmdz_bert_large_cased_finetuned_conll03_english -- ^ @"dbmdz-bert-large-cased-finetuned-conll03-english"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model10 where toJSON = A.toJSON . fromE'Model10
instance A.FromJSON E'Model10 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model10 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model10 where toQueryParam = WH.toQueryParam . fromE'Model10
instance WH.FromHttpApiData E'Model10 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model10
instance MimeRender MimeMultipartFormData E'Model10 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model10' enum
fromE'Model10 :: E'Model10 -> Text
fromE'Model10 = \case
  E'Model10'Dbmdz_bert_large_cased_finetuned_conll03_english -> "dbmdz-bert-large-cased-finetuned-conll03-english"

-- | parse 'E'Model10' enum
toE'Model10 :: Text -> P.Either String E'Model10
toE'Model10 = \case
  "dbmdz-bert-large-cased-finetuned-conll03-english" -> P.Right E'Model10'Dbmdz_bert_large_cased_finetuned_conll03_english
  s -> P.Left $ "toE'Model10: enum parse failure: " P.++ P.show s


-- ** E'Model11

-- | Enum of 'Text'
data E'Model11
  = E'Model11'Hate_speech_CNERG_dehatebert_mono_english -- ^ @"Hate-speech-CNERG-dehatebert-mono-english"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model11 where toJSON = A.toJSON . fromE'Model11
instance A.FromJSON E'Model11 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model11 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model11 where toQueryParam = WH.toQueryParam . fromE'Model11
instance WH.FromHttpApiData E'Model11 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model11
instance MimeRender MimeMultipartFormData E'Model11 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model11' enum
fromE'Model11 :: E'Model11 -> Text
fromE'Model11 = \case
  E'Model11'Hate_speech_CNERG_dehatebert_mono_english -> "Hate-speech-CNERG-dehatebert-mono-english"

-- | parse 'E'Model11' enum
toE'Model11 :: Text -> P.Either String E'Model11
toE'Model11 = \case
  "Hate-speech-CNERG-dehatebert-mono-english" -> P.Right E'Model11'Hate_speech_CNERG_dehatebert_mono_english
  s -> P.Left $ "toE'Model11: enum parse failure: " P.++ P.show s


-- ** E'Model12

-- | Enum of 'Text'
data E'Model12
  = E'Model12'MiniLM_L6_v2 -- ^ @"keybert-paraphrase-MiniLM-L6-v2"@
  | E'Model12'Multilingual_MiniLM_L12_v2 -- ^ @"keybert-paraphrase-multilingual-MiniLM-L12-v2"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model12 where toJSON = A.toJSON . fromE'Model12
instance A.FromJSON E'Model12 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model12 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model12 where toQueryParam = WH.toQueryParam . fromE'Model12
instance WH.FromHttpApiData E'Model12 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model12
instance MimeRender MimeMultipartFormData E'Model12 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model12' enum
fromE'Model12 :: E'Model12 -> Text
fromE'Model12 = \case
  E'Model12'MiniLM_L6_v2 -> "keybert-paraphrase-MiniLM-L6-v2"
  E'Model12'Multilingual_MiniLM_L12_v2 -> "keybert-paraphrase-multilingual-MiniLM-L12-v2"

-- | parse 'E'Model12' enum
toE'Model12 :: Text -> P.Either String E'Model12
toE'Model12 = \case
  "keybert-paraphrase-MiniLM-L6-v2" -> P.Right E'Model12'MiniLM_L6_v2
  "keybert-paraphrase-multilingual-MiniLM-L12-v2" -> P.Right E'Model12'Multilingual_MiniLM_L12_v2
  s -> P.Left $ "toE'Model12: enum parse failure: " P.++ P.show s


-- ** E'Model13

-- | Enum of 'Text'
data E'Model13
  = E'Model13'Toftrup_etal_2021 -- ^ @"toftrup-etal-2021"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model13 where toJSON = A.toJSON . fromE'Model13
instance A.FromJSON E'Model13 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model13 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model13 where toQueryParam = WH.toQueryParam . fromE'Model13
instance WH.FromHttpApiData E'Model13 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model13
instance MimeRender MimeMultipartFormData E'Model13 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model13' enum
fromE'Model13 :: E'Model13 -> Text
fromE'Model13 = \case
  E'Model13'Toftrup_etal_2021 -> "toftrup-etal-2021"

-- | parse 'E'Model13' enum
toE'Model13 :: Text -> P.Either String E'Model13
toE'Model13 = \case
  "toftrup-etal-2021" -> P.Right E'Model13'Toftrup_etal_2021
  s -> P.Left $ "toE'Model13: enum parse failure: " P.++ P.show s


-- ** E'Model14

-- | Enum of 'Text'
data E'Model14
  = E'Model14'EleutherAI_gpt_neo_2_7B -- ^ @"EleutherAI-gpt-neo-2_7B"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model14 where toJSON = A.toJSON . fromE'Model14
instance A.FromJSON E'Model14 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model14 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model14 where toQueryParam = WH.toQueryParam . fromE'Model14
instance WH.FromHttpApiData E'Model14 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model14
instance MimeRender MimeMultipartFormData E'Model14 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model14' enum
fromE'Model14 :: E'Model14 -> Text
fromE'Model14 = \case
  E'Model14'EleutherAI_gpt_neo_2_7B -> "EleutherAI-gpt-neo-2_7B"

-- | parse 'E'Model14' enum
toE'Model14 :: Text -> P.Either String E'Model14
toE'Model14 = \case
  "EleutherAI-gpt-neo-2_7B" -> P.Right E'Model14'EleutherAI_gpt_neo_2_7B
  s -> P.Left $ "toE'Model14: enum parse failure: " P.++ P.show s


-- ** E'Model15

-- | Enum of 'Text'
data E'Model15
  = E'Model15'Wordnet -- ^ @"wordnet"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model15 where toJSON = A.toJSON . fromE'Model15
instance A.FromJSON E'Model15 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model15 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model15 where toQueryParam = WH.toQueryParam . fromE'Model15
instance WH.FromHttpApiData E'Model15 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model15
instance MimeRender MimeMultipartFormData E'Model15 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model15' enum
fromE'Model15 :: E'Model15 -> Text
fromE'Model15 = \case
  E'Model15'Wordnet -> "wordnet"

-- | parse 'E'Model15' enum
toE'Model15 :: Text -> P.Either String E'Model15
toE'Model15 = \case
  "wordnet" -> P.Right E'Model15'Wordnet
  s -> P.Left $ "toE'Model15: enum parse failure: " P.++ P.show s


-- ** E'Model16

-- | Enum of 'Text'
data E'Model16
  = E'Model16'Bert_base_uncased -- ^ @"bert-base-uncased"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model16 where toJSON = A.toJSON . fromE'Model16
instance A.FromJSON E'Model16 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model16 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model16 where toQueryParam = WH.toQueryParam . fromE'Model16
instance WH.FromHttpApiData E'Model16 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model16
instance MimeRender MimeMultipartFormData E'Model16 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model16' enum
fromE'Model16 :: E'Model16 -> Text
fromE'Model16 = \case
  E'Model16'Bert_base_uncased -> "bert-base-uncased"

-- | parse 'E'Model16' enum
toE'Model16 :: Text -> P.Either String E'Model16
toE'Model16 = \case
  "bert-base-uncased" -> P.Right E'Model16'Bert_base_uncased
  s -> P.Left $ "toE'Model16: enum parse failure: " P.++ P.show s


-- ** E'Model17

-- | Enum of 'Text'
data E'Model17
  = E'Model17'Bert_base_uncased -- ^ @"bert-base-uncased"@
  | E'Model17'Albert_base_v2 -- ^ @"albert-base-v2"@
  | E'Model17'Distilbert_base_uncased -- ^ @"distilbert-base-uncased"@
  | E'Model17'Roberta_base -- ^ @"roberta-base"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model17 where toJSON = A.toJSON . fromE'Model17
instance A.FromJSON E'Model17 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model17 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model17 where toQueryParam = WH.toQueryParam . fromE'Model17
instance WH.FromHttpApiData E'Model17 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model17
instance MimeRender MimeMultipartFormData E'Model17 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model17' enum
fromE'Model17 :: E'Model17 -> Text
fromE'Model17 = \case
  E'Model17'Bert_base_uncased -> "bert-base-uncased"
  E'Model17'Albert_base_v2 -> "albert-base-v2"
  E'Model17'Distilbert_base_uncased -> "distilbert-base-uncased"
  E'Model17'Roberta_base -> "roberta-base"

-- | parse 'E'Model17' enum
toE'Model17 :: Text -> P.Either String E'Model17
toE'Model17 = \case
  "bert-base-uncased" -> P.Right E'Model17'Bert_base_uncased
  "albert-base-v2" -> P.Right E'Model17'Albert_base_v2
  "distilbert-base-uncased" -> P.Right E'Model17'Distilbert_base_uncased
  "roberta-base" -> P.Right E'Model17'Roberta_base
  s -> P.Left $ "toE'Model17: enum parse failure: " P.++ P.show s


-- ** E'Model18

-- | Enum of 'Text'
data E'Model18
  = E'Model18'Inflect -- ^ @"inflect"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model18 where toJSON = A.toJSON . fromE'Model18
instance A.FromJSON E'Model18 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model18 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model18 where toQueryParam = WH.toQueryParam . fromE'Model18
instance WH.FromHttpApiData E'Model18 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model18
instance MimeRender MimeMultipartFormData E'Model18 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model18' enum
fromE'Model18 :: E'Model18 -> Text
fromE'Model18 = \case
  E'Model18'Inflect -> "inflect"

-- | parse 'E'Model18' enum
toE'Model18 :: Text -> P.Either String E'Model18
toE'Model18 = \case
  "inflect" -> P.Right E'Model18'Inflect
  s -> P.Left $ "toE'Model18: enum parse failure: " P.++ P.show s


-- ** E'Model19

-- | Enum of 'Text'
data E'Model19
  = E'Model19'Sentdex_GPyT -- ^ @"sentdex-GPyT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model19 where toJSON = A.toJSON . fromE'Model19
instance A.FromJSON E'Model19 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model19 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model19 where toQueryParam = WH.toQueryParam . fromE'Model19
instance WH.FromHttpApiData E'Model19 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model19
instance MimeRender MimeMultipartFormData E'Model19 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model19' enum
fromE'Model19 :: E'Model19 -> Text
fromE'Model19 = \case
  E'Model19'Sentdex_GPyT -> "sentdex-GPyT"

-- | parse 'E'Model19' enum
toE'Model19 :: Text -> P.Either String E'Model19
toE'Model19 = \case
  "sentdex-GPyT" -> P.Right E'Model19'Sentdex_GPyT
  s -> P.Left $ "toE'Model19: enum parse failure: " P.++ P.show s


-- ** E'Model2

-- | Enum of 'Text'
data E'Model2
  = E'Model2'Stable -- ^ @"deoldify-stable"@
  | E'Model2'Artistic -- ^ @"deoldify-artistic"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model2 where toJSON = A.toJSON . fromE'Model2
instance A.FromJSON E'Model2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model2 where toQueryParam = WH.toQueryParam . fromE'Model2
instance WH.FromHttpApiData E'Model2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model2
instance MimeRender MimeMultipartFormData E'Model2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model2' enum
fromE'Model2 :: E'Model2 -> Text
fromE'Model2 = \case
  E'Model2'Stable -> "deoldify-stable"
  E'Model2'Artistic -> "deoldify-artistic"

-- | parse 'E'Model2' enum
toE'Model2 :: Text -> P.Either String E'Model2
toE'Model2 = \case
  "deoldify-stable" -> P.Right E'Model2'Stable
  "deoldify-artistic" -> P.Right E'Model2'Artistic
  s -> P.Left $ "toE'Model2: enum parse failure: " P.++ P.show s


-- ** E'Model20

-- | Enum of 'Text'
data E'Model20
  = E'Model20'Mrm8488_bert_tiny_5_finetuned_squadv2 -- ^ @"mrm8488-bert-tiny-5-finetuned-squadv2"@
  | E'Model20'Mfeb_albert_xxlarge_v2_squad2 -- ^ @"mfeb-albert-xxlarge-v2-squad2"@
  | E'Model20'Deepset_roberta_base_squad2 -- ^ @"deepset-roberta-base-squad2"@
  | E'Model20'Distilbert_base_cased_distilled_squad -- ^ @"distilbert-base-cased-distilled-squad"@
  | E'Model20'Deepset_bert_base_cased_squad2 -- ^ @"deepset_bert-base-cased-squad2"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model20 where toJSON = A.toJSON . fromE'Model20
instance A.FromJSON E'Model20 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model20 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model20 where toQueryParam = WH.toQueryParam . fromE'Model20
instance WH.FromHttpApiData E'Model20 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model20
instance MimeRender MimeMultipartFormData E'Model20 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model20' enum
fromE'Model20 :: E'Model20 -> Text
fromE'Model20 = \case
  E'Model20'Mrm8488_bert_tiny_5_finetuned_squadv2 -> "mrm8488-bert-tiny-5-finetuned-squadv2"
  E'Model20'Mfeb_albert_xxlarge_v2_squad2 -> "mfeb-albert-xxlarge-v2-squad2"
  E'Model20'Deepset_roberta_base_squad2 -> "deepset-roberta-base-squad2"
  E'Model20'Distilbert_base_cased_distilled_squad -> "distilbert-base-cased-distilled-squad"
  E'Model20'Deepset_bert_base_cased_squad2 -> "deepset_bert-base-cased-squad2"

-- | parse 'E'Model20' enum
toE'Model20 :: Text -> P.Either String E'Model20
toE'Model20 = \case
  "mrm8488-bert-tiny-5-finetuned-squadv2" -> P.Right E'Model20'Mrm8488_bert_tiny_5_finetuned_squadv2
  "mfeb-albert-xxlarge-v2-squad2" -> P.Right E'Model20'Mfeb_albert_xxlarge_v2_squad2
  "deepset-roberta-base-squad2" -> P.Right E'Model20'Deepset_roberta_base_squad2
  "distilbert-base-cased-distilled-squad" -> P.Right E'Model20'Distilbert_base_cased_distilled_squad
  "deepset_bert-base-cased-squad2" -> P.Right E'Model20'Deepset_bert_base_cased_squad2
  s -> P.Left $ "toE'Model20: enum parse failure: " P.++ P.show s


-- ** E'Model21

-- | Enum of 'Text'
data E'Model21
  = E'Model21'Ramsrigouthamg_t5_large_paraphraser_diverse_high_quality -- ^ @"ramsrigouthamg-t5-large-paraphraser-diverse-high-quality"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model21 where toJSON = A.toJSON . fromE'Model21
instance A.FromJSON E'Model21 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model21 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model21 where toQueryParam = WH.toQueryParam . fromE'Model21
instance WH.FromHttpApiData E'Model21 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model21
instance MimeRender MimeMultipartFormData E'Model21 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model21' enum
fromE'Model21 :: E'Model21 -> Text
fromE'Model21 = \case
  E'Model21'Ramsrigouthamg_t5_large_paraphraser_diverse_high_quality -> "ramsrigouthamg-t5-large-paraphraser-diverse-high-quality"

-- | parse 'E'Model21' enum
toE'Model21 :: Text -> P.Either String E'Model21
toE'Model21 = \case
  "ramsrigouthamg-t5-large-paraphraser-diverse-high-quality" -> P.Right E'Model21'Ramsrigouthamg_t5_large_paraphraser_diverse_high_quality
  s -> P.Left $ "toE'Model21: enum parse failure: " P.++ P.show s


-- ** E'Model22

-- | Enum of 'Text'
data E'Model22
  = E'Model22'Zero_shot_classification_facebook_bart_large_mnli -- ^ @"zero-shot-classification-facebook-bart-large-mnli"@
  | E'Model22'Distilbert_base_uncased -- ^ @"distilbert-base-uncased"@
  | E'Model22'Nlptown_bert_base_multilingual_uncased_sentiment -- ^ @"nlptown-bert-base-multilingual-uncased-sentiment"@
  | E'Model22'Distilbert_base_uncased_finetuned_sst_2_english -- ^ @"distilbert-base-uncased-finetuned-sst-2-english"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model22 where toJSON = A.toJSON . fromE'Model22
instance A.FromJSON E'Model22 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model22 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model22 where toQueryParam = WH.toQueryParam . fromE'Model22
instance WH.FromHttpApiData E'Model22 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model22
instance MimeRender MimeMultipartFormData E'Model22 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model22' enum
fromE'Model22 :: E'Model22 -> Text
fromE'Model22 = \case
  E'Model22'Zero_shot_classification_facebook_bart_large_mnli -> "zero-shot-classification-facebook-bart-large-mnli"
  E'Model22'Distilbert_base_uncased -> "distilbert-base-uncased"
  E'Model22'Nlptown_bert_base_multilingual_uncased_sentiment -> "nlptown-bert-base-multilingual-uncased-sentiment"
  E'Model22'Distilbert_base_uncased_finetuned_sst_2_english -> "distilbert-base-uncased-finetuned-sst-2-english"

-- | parse 'E'Model22' enum
toE'Model22 :: Text -> P.Either String E'Model22
toE'Model22 = \case
  "zero-shot-classification-facebook-bart-large-mnli" -> P.Right E'Model22'Zero_shot_classification_facebook_bart_large_mnli
  "distilbert-base-uncased" -> P.Right E'Model22'Distilbert_base_uncased
  "nlptown-bert-base-multilingual-uncased-sentiment" -> P.Right E'Model22'Nlptown_bert_base_multilingual_uncased_sentiment
  "distilbert-base-uncased-finetuned-sst-2-english" -> P.Right E'Model22'Distilbert_base_uncased_finetuned_sst_2_english
  s -> P.Left $ "toE'Model22: enum parse failure: " P.++ P.show s


-- ** E'Model23

-- | Enum of 'Text'
data E'Model23
  = E'Model23'All_MiniLM_L6_v2 -- ^ @"all-MiniLM-L6-v2"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model23 where toJSON = A.toJSON . fromE'Model23
instance A.FromJSON E'Model23 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model23 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model23 where toQueryParam = WH.toQueryParam . fromE'Model23
instance WH.FromHttpApiData E'Model23 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model23
instance MimeRender MimeMultipartFormData E'Model23 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model23' enum
fromE'Model23 :: E'Model23 -> Text
fromE'Model23 = \case
  E'Model23'All_MiniLM_L6_v2 -> "all-MiniLM-L6-v2"

-- | parse 'E'Model23' enum
toE'Model23 :: Text -> P.Either String E'Model23
toE'Model23 = \case
  "all-MiniLM-L6-v2" -> P.Right E'Model23'All_MiniLM_L6_v2
  s -> P.Left $ "toE'Model23: enum parse failure: " P.++ P.show s


-- ** E'Model24

-- | Enum of 'Text'
data E'Model24
  = E'Model24'Bert_base_multilingual_cased -- ^ @"bert-base-multilingual-cased"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model24 where toJSON = A.toJSON . fromE'Model24
instance A.FromJSON E'Model24 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model24 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model24 where toQueryParam = WH.toQueryParam . fromE'Model24
instance WH.FromHttpApiData E'Model24 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model24
instance MimeRender MimeMultipartFormData E'Model24 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model24' enum
fromE'Model24 :: E'Model24 -> Text
fromE'Model24 = \case
  E'Model24'Bert_base_multilingual_cased -> "bert-base-multilingual-cased"

-- | parse 'E'Model24' enum
toE'Model24 :: Text -> P.Either String E'Model24
toE'Model24 = \case
  "bert-base-multilingual-cased" -> P.Right E'Model24'Bert_base_multilingual_cased
  s -> P.Left $ "toE'Model24: enum parse failure: " P.++ P.show s


-- ** E'Model3

-- | Enum of 'Text'
data E'Model3
  = E'Model3'Ageitgey -- ^ @"ageitgey"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model3 where toJSON = A.toJSON . fromE'Model3
instance A.FromJSON E'Model3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model3 where toQueryParam = WH.toQueryParam . fromE'Model3
instance WH.FromHttpApiData E'Model3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model3
instance MimeRender MimeMultipartFormData E'Model3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model3' enum
fromE'Model3 :: E'Model3 -> Text
fromE'Model3 = \case
  E'Model3'Ageitgey -> "ageitgey"

-- | parse 'E'Model3' enum
toE'Model3 :: Text -> P.Either String E'Model3
toE'Model3 = \case
  "ageitgey" -> P.Right E'Model3'Ageitgey
  s -> P.Left $ "toE'Model3: enum parse failure: " P.++ P.show s


-- ** E'Model4

-- | Enum of 'Text'
data E'Model4
  = E'Model4'Idealo_psnr_small -- ^ @"idealo-psnr-small"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model4 where toJSON = A.toJSON . fromE'Model4
instance A.FromJSON E'Model4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model4 where toQueryParam = WH.toQueryParam . fromE'Model4
instance WH.FromHttpApiData E'Model4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model4
instance MimeRender MimeMultipartFormData E'Model4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model4' enum
fromE'Model4 :: E'Model4 -> Text
fromE'Model4 = \case
  E'Model4'Idealo_psnr_small -> "idealo-psnr-small"

-- | parse 'E'Model4' enum
toE'Model4 :: Text -> P.Either String E'Model4
toE'Model4 = \case
  "idealo-psnr-small" -> P.Right E'Model4'Idealo_psnr_small
  s -> P.Left $ "toE'Model4: enum parse failure: " P.++ P.show s


-- ** E'Model5

-- | Enum of 'Text'
data E'Model5
  = E'Model5'V1 -- ^ @"v1"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model5 where toJSON = A.toJSON . fromE'Model5
instance A.FromJSON E'Model5 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model5 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model5 where toQueryParam = WH.toQueryParam . fromE'Model5
instance WH.FromHttpApiData E'Model5 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model5
instance MimeRender MimeMultipartFormData E'Model5 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model5' enum
fromE'Model5 :: E'Model5 -> Text
fromE'Model5 = \case
  E'Model5'V1 -> "v1"

-- | parse 'E'Model5' enum
toE'Model5 :: Text -> P.Either String E'Model5
toE'Model5 = \case
  "v1" -> P.Right E'Model5'V1
  s -> P.Left $ "toE'Model5: enum parse failure: " P.++ P.show s


-- ** E'Model6

-- | Enum of 'Text'
data E'Model6
  = E'Model6'Ramesh_aditya -- ^ @"ramesh-aditya"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model6 where toJSON = A.toJSON . fromE'Model6
instance A.FromJSON E'Model6 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model6 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model6 where toQueryParam = WH.toQueryParam . fromE'Model6
instance WH.FromHttpApiData E'Model6 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model6
instance MimeRender MimeMultipartFormData E'Model6 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model6' enum
fromE'Model6 :: E'Model6 -> Text
fromE'Model6 = \case
  E'Model6'Ramesh_aditya -> "ramesh-aditya"

-- | parse 'E'Model6' enum
toE'Model6 :: Text -> P.Either String E'Model6
toE'Model6 = \case
  "ramesh-aditya" -> P.Right E'Model6'Ramesh_aditya
  s -> P.Left $ "toE'Model6: enum parse failure: " P.++ P.show s


-- ** E'Model7

-- | Enum of 'Text'
data E'Model7
  = E'Model7'Tesseract_denoising -- ^ @"tesseract-denoising"@
  | E'Model7'Easy_ocr -- ^ @"easy-ocr"@
  | E'Model7'Tesseract_default -- ^ @"tesseract-default"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model7 where toJSON = A.toJSON . fromE'Model7
instance A.FromJSON E'Model7 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model7 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model7 where toQueryParam = WH.toQueryParam . fromE'Model7
instance WH.FromHttpApiData E'Model7 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model7
instance MimeRender MimeMultipartFormData E'Model7 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model7' enum
fromE'Model7 :: E'Model7 -> Text
fromE'Model7 = \case
  E'Model7'Tesseract_denoising -> "tesseract-denoising"
  E'Model7'Easy_ocr -> "easy-ocr"
  E'Model7'Tesseract_default -> "tesseract-default"

-- | parse 'E'Model7' enum
toE'Model7 :: Text -> P.Either String E'Model7
toE'Model7 = \case
  "tesseract-denoising" -> P.Right E'Model7'Tesseract_denoising
  "easy-ocr" -> P.Right E'Model7'Easy_ocr
  "tesseract-default" -> P.Right E'Model7'Tesseract_default
  s -> P.Left $ "toE'Model7: enum parse failure: " P.++ P.show s


-- ** E'Model8

-- | Enum of 'Text'
data E'Model8
  = E'Model8'Flexudy_t5_base_multi_sentence_doctor -- ^ @"flexudy-t5-base-multi-sentence-doctor"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model8 where toJSON = A.toJSON . fromE'Model8
instance A.FromJSON E'Model8 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model8 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model8 where toQueryParam = WH.toQueryParam . fromE'Model8
instance WH.FromHttpApiData E'Model8 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model8
instance MimeRender MimeMultipartFormData E'Model8 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model8' enum
fromE'Model8 :: E'Model8 -> Text
fromE'Model8 = \case
  E'Model8'Flexudy_t5_base_multi_sentence_doctor -> "flexudy-t5-base-multi-sentence-doctor"

-- | parse 'E'Model8' enum
toE'Model8 :: Text -> P.Either String E'Model8
toE'Model8 = \case
  "flexudy-t5-base-multi-sentence-doctor" -> P.Right E'Model8'Flexudy_t5_base_multi_sentence_doctor
  s -> P.Left $ "toE'Model8: enum parse failure: " P.++ P.show s


-- ** E'Model9

-- | Enum of 'Text'
data E'Model9
  = E'Model9'Mrm8488_t5_base_finetuned_emotion -- ^ @"mrm8488-t5-base-finetuned-emotion"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Model9 where toJSON = A.toJSON . fromE'Model9
instance A.FromJSON E'Model9 where parseJSON o = P.either P.fail (pure . P.id) . toE'Model9 =<< A.parseJSON o
instance WH.ToHttpApiData E'Model9 where toQueryParam = WH.toQueryParam . fromE'Model9
instance WH.FromHttpApiData E'Model9 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Model9
instance MimeRender MimeMultipartFormData E'Model9 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Model9' enum
fromE'Model9 :: E'Model9 -> Text
fromE'Model9 = \case
  E'Model9'Mrm8488_t5_base_finetuned_emotion -> "mrm8488-t5-base-finetuned-emotion"

-- | parse 'E'Model9' enum
toE'Model9 :: Text -> P.Either String E'Model9
toE'Model9 = \case
  "mrm8488-t5-base-finetuned-emotion" -> P.Right E'Model9'Mrm8488_t5_base_finetuned_emotion
  s -> P.Left $ "toE'Model9: enum parse failure: " P.++ P.show s



