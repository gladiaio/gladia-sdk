// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BodyApplyImageImageBackgroundRemovalPost
 */
export interface BodyApplyImageImageBackgroundRemovalPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageBackgroundRemovalPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface BodyApplyImageImageColorizationPost
 */
export interface BodyApplyImageImageColorizationPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageColorizationPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface BodyApplyImageImageFaceBluringPost
 */
export interface BodyApplyImageImageFaceBluringPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageFaceBluringPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface BodyApplyImageImageSuperResolutionPost
 */
export interface BodyApplyImageImageSuperResolutionPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageSuperResolutionPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface BodyApplyImageImageUncolorizationPost
 */
export interface BodyApplyImageImageUncolorizationPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageUncolorizationPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface BodyApplyImageTextAsciifyPost
 */
export interface BodyApplyImageTextAsciifyPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageTextAsciifyPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface BodyApplyImageTextOcrPost
 */
export interface BodyApplyImageTextOcrPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageTextOcrPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}

/**
 * ImageImageBackgroundRemovalApi - axios parameter creator
 * @export
 */
export const ImageImageBackgroundRemovalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the background-removal task for a given models
         * @param {any} image 
         * @param {'mobilenet' | 'xception'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageBackgroundRemovalPost(image: any, model?: 'mobilenet' | 'xception', options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageBackgroundRemovalPost.');
            }
            const localVarPath = `/image/image/background-removal/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for background-removal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageBackgroundRemovalGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/image/background-removal/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageImageBackgroundRemovalApi - functional programming interface
 * @export
 */
export const ImageImageBackgroundRemovalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the background-removal task for a given models
         * @param {any} image 
         * @param {'mobilenet' | 'xception'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageBackgroundRemovalPost(image: any, model?: 'mobilenet' | 'xception', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageBackgroundRemovalApiAxiosParamCreator(configuration).applyImageImageBackgroundRemovalPost(image, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for background-removal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageBackgroundRemovalGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageBackgroundRemovalApiAxiosParamCreator(configuration).getVersionsImageImageBackgroundRemovalGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageImageBackgroundRemovalApi - factory interface
 * @export
 */
export const ImageImageBackgroundRemovalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the background-removal task for a given models
         * @param {any} image 
         * @param {'mobilenet' | 'xception'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageBackgroundRemovalPost(image: any, model?: 'mobilenet' | 'xception', options?: any) {
            return ImageImageBackgroundRemovalApiFp(configuration).applyImageImageBackgroundRemovalPost(image, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for background-removal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageBackgroundRemovalGet(options?: any) {
            return ImageImageBackgroundRemovalApiFp(configuration).getVersionsImageImageBackgroundRemovalGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageImageBackgroundRemovalApi - object-oriented interface
 * @export
 * @class ImageImageBackgroundRemovalApi
 * @extends {BaseAPI}
 */
export class ImageImageBackgroundRemovalApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the background-removal task for a given models
     * @param {any} image 
     * @param {'mobilenet' | 'xception'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageBackgroundRemovalApi
     */
    public applyImageImageBackgroundRemovalPost(image: any, model?: 'mobilenet' | 'xception', options?: any) {
        return ImageImageBackgroundRemovalApiFp(this.configuration).applyImageImageBackgroundRemovalPost(image, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for background-removal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageBackgroundRemovalApi
     */
    public getVersionsImageImageBackgroundRemovalGet(options?: any) {
        return ImageImageBackgroundRemovalApiFp(this.configuration).getVersionsImageImageBackgroundRemovalGet(options)(this.axios, this.basePath);
    }

}


/**
 * ImageImageColorizationApi - axios parameter creator
 * @export
 */
export const ImageImageColorizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the colorization task for a given models
         * @param {any} image 
         * @param {'deoldify-stable' | 'deoldify-artistic'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageColorizationPost(image: any, model?: 'deoldify-stable' | 'deoldify-artistic', options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageColorizationPost.');
            }
            const localVarPath = `/image/image/colorization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for colorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageColorizationGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/image/colorization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageImageColorizationApi - functional programming interface
 * @export
 */
export const ImageImageColorizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the colorization task for a given models
         * @param {any} image 
         * @param {'deoldify-stable' | 'deoldify-artistic'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageColorizationPost(image: any, model?: 'deoldify-stable' | 'deoldify-artistic', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageColorizationApiAxiosParamCreator(configuration).applyImageImageColorizationPost(image, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for colorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageColorizationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageColorizationApiAxiosParamCreator(configuration).getVersionsImageImageColorizationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageImageColorizationApi - factory interface
 * @export
 */
export const ImageImageColorizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the colorization task for a given models
         * @param {any} image 
         * @param {'deoldify-stable' | 'deoldify-artistic'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageColorizationPost(image: any, model?: 'deoldify-stable' | 'deoldify-artistic', options?: any) {
            return ImageImageColorizationApiFp(configuration).applyImageImageColorizationPost(image, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for colorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageColorizationGet(options?: any) {
            return ImageImageColorizationApiFp(configuration).getVersionsImageImageColorizationGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageImageColorizationApi - object-oriented interface
 * @export
 * @class ImageImageColorizationApi
 * @extends {BaseAPI}
 */
export class ImageImageColorizationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the colorization task for a given models
     * @param {any} image 
     * @param {'deoldify-stable' | 'deoldify-artistic'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageColorizationApi
     */
    public applyImageImageColorizationPost(image: any, model?: 'deoldify-stable' | 'deoldify-artistic', options?: any) {
        return ImageImageColorizationApiFp(this.configuration).applyImageImageColorizationPost(image, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for colorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageColorizationApi
     */
    public getVersionsImageImageColorizationGet(options?: any) {
        return ImageImageColorizationApiFp(this.configuration).getVersionsImageImageColorizationGet(options)(this.axios, this.basePath);
    }

}


/**
 * ImageImageFaceBluringApi - axios parameter creator
 * @export
 */
export const ImageImageFaceBluringApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the face-bluring task for a given models
         * @param {any} image 
         * @param {'ageitgey'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageFaceBluringPost(image: any, model?: 'ageitgey', options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageFaceBluringPost.');
            }
            const localVarPath = `/image/image/face-bluring/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for face-bluring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageFaceBluringGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/image/face-bluring/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageImageFaceBluringApi - functional programming interface
 * @export
 */
export const ImageImageFaceBluringApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the face-bluring task for a given models
         * @param {any} image 
         * @param {'ageitgey'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageFaceBluringPost(image: any, model?: 'ageitgey', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageFaceBluringApiAxiosParamCreator(configuration).applyImageImageFaceBluringPost(image, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for face-bluring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageFaceBluringGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageFaceBluringApiAxiosParamCreator(configuration).getVersionsImageImageFaceBluringGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageImageFaceBluringApi - factory interface
 * @export
 */
export const ImageImageFaceBluringApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the face-bluring task for a given models
         * @param {any} image 
         * @param {'ageitgey'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageFaceBluringPost(image: any, model?: 'ageitgey', options?: any) {
            return ImageImageFaceBluringApiFp(configuration).applyImageImageFaceBluringPost(image, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for face-bluring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageFaceBluringGet(options?: any) {
            return ImageImageFaceBluringApiFp(configuration).getVersionsImageImageFaceBluringGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageImageFaceBluringApi - object-oriented interface
 * @export
 * @class ImageImageFaceBluringApi
 * @extends {BaseAPI}
 */
export class ImageImageFaceBluringApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the face-bluring task for a given models
     * @param {any} image 
     * @param {'ageitgey'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageFaceBluringApi
     */
    public applyImageImageFaceBluringPost(image: any, model?: 'ageitgey', options?: any) {
        return ImageImageFaceBluringApiFp(this.configuration).applyImageImageFaceBluringPost(image, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for face-bluring
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageFaceBluringApi
     */
    public getVersionsImageImageFaceBluringGet(options?: any) {
        return ImageImageFaceBluringApiFp(this.configuration).getVersionsImageImageFaceBluringGet(options)(this.axios, this.basePath);
    }

}


/**
 * ImageImageSuperResolutionApi - axios parameter creator
 * @export
 */
export const ImageImageSuperResolutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the super-resolution task for a given models
         * @param {any} image 
         * @param {'idealo-psnr-small'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageSuperResolutionPost(image: any, model?: 'idealo-psnr-small', options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageSuperResolutionPost.');
            }
            const localVarPath = `/image/image/super-resolution/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for super-resolution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageSuperResolutionGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/image/super-resolution/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageImageSuperResolutionApi - functional programming interface
 * @export
 */
export const ImageImageSuperResolutionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the super-resolution task for a given models
         * @param {any} image 
         * @param {'idealo-psnr-small'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageSuperResolutionPost(image: any, model?: 'idealo-psnr-small', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageSuperResolutionApiAxiosParamCreator(configuration).applyImageImageSuperResolutionPost(image, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for super-resolution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageSuperResolutionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageSuperResolutionApiAxiosParamCreator(configuration).getVersionsImageImageSuperResolutionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageImageSuperResolutionApi - factory interface
 * @export
 */
export const ImageImageSuperResolutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the super-resolution task for a given models
         * @param {any} image 
         * @param {'idealo-psnr-small'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageSuperResolutionPost(image: any, model?: 'idealo-psnr-small', options?: any) {
            return ImageImageSuperResolutionApiFp(configuration).applyImageImageSuperResolutionPost(image, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for super-resolution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageSuperResolutionGet(options?: any) {
            return ImageImageSuperResolutionApiFp(configuration).getVersionsImageImageSuperResolutionGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageImageSuperResolutionApi - object-oriented interface
 * @export
 * @class ImageImageSuperResolutionApi
 * @extends {BaseAPI}
 */
export class ImageImageSuperResolutionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the super-resolution task for a given models
     * @param {any} image 
     * @param {'idealo-psnr-small'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageSuperResolutionApi
     */
    public applyImageImageSuperResolutionPost(image: any, model?: 'idealo-psnr-small', options?: any) {
        return ImageImageSuperResolutionApiFp(this.configuration).applyImageImageSuperResolutionPost(image, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for super-resolution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageSuperResolutionApi
     */
    public getVersionsImageImageSuperResolutionGet(options?: any) {
        return ImageImageSuperResolutionApiFp(this.configuration).getVersionsImageImageSuperResolutionGet(options)(this.axios, this.basePath);
    }

}


/**
 * ImageImageUncolorizationApi - axios parameter creator
 * @export
 */
export const ImageImageUncolorizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the uncolorization task for a given models
         * @param {any} image 
         * @param {'v1'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageUncolorizationPost(image: any, model?: 'v1', options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageUncolorizationPost.');
            }
            const localVarPath = `/image/image/uncolorization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for uncolorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageUncolorizationGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/image/uncolorization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageImageUncolorizationApi - functional programming interface
 * @export
 */
export const ImageImageUncolorizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the uncolorization task for a given models
         * @param {any} image 
         * @param {'v1'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageUncolorizationPost(image: any, model?: 'v1', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageUncolorizationApiAxiosParamCreator(configuration).applyImageImageUncolorizationPost(image, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for uncolorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageUncolorizationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageUncolorizationApiAxiosParamCreator(configuration).getVersionsImageImageUncolorizationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageImageUncolorizationApi - factory interface
 * @export
 */
export const ImageImageUncolorizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the uncolorization task for a given models
         * @param {any} image 
         * @param {'v1'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageUncolorizationPost(image: any, model?: 'v1', options?: any) {
            return ImageImageUncolorizationApiFp(configuration).applyImageImageUncolorizationPost(image, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for uncolorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageUncolorizationGet(options?: any) {
            return ImageImageUncolorizationApiFp(configuration).getVersionsImageImageUncolorizationGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageImageUncolorizationApi - object-oriented interface
 * @export
 * @class ImageImageUncolorizationApi
 * @extends {BaseAPI}
 */
export class ImageImageUncolorizationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the uncolorization task for a given models
     * @param {any} image 
     * @param {'v1'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageUncolorizationApi
     */
    public applyImageImageUncolorizationPost(image: any, model?: 'v1', options?: any) {
        return ImageImageUncolorizationApiFp(this.configuration).applyImageImageUncolorizationPost(image, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for uncolorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageUncolorizationApi
     */
    public getVersionsImageImageUncolorizationGet(options?: any) {
        return ImageImageUncolorizationApiFp(this.configuration).getVersionsImageImageUncolorizationGet(options)(this.axios, this.basePath);
    }

}


/**
 * ImageTextAsciifyApi - axios parameter creator
 * @export
 */
export const ImageTextAsciifyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the asciify task for a given models
         * @param {any} image 
         * @param {'ramesh-aditya'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageTextAsciifyPost(image: any, model?: 'ramesh-aditya', options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageTextAsciifyPost.');
            }
            const localVarPath = `/image/text/asciify/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for asciify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageTextAsciifyGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/text/asciify/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageTextAsciifyApi - functional programming interface
 * @export
 */
export const ImageTextAsciifyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the asciify task for a given models
         * @param {any} image 
         * @param {'ramesh-aditya'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageTextAsciifyPost(image: any, model?: 'ramesh-aditya', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageTextAsciifyApiAxiosParamCreator(configuration).applyImageTextAsciifyPost(image, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for asciify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageTextAsciifyGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageTextAsciifyApiAxiosParamCreator(configuration).getVersionsImageTextAsciifyGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageTextAsciifyApi - factory interface
 * @export
 */
export const ImageTextAsciifyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the asciify task for a given models
         * @param {any} image 
         * @param {'ramesh-aditya'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageTextAsciifyPost(image: any, model?: 'ramesh-aditya', options?: any) {
            return ImageTextAsciifyApiFp(configuration).applyImageTextAsciifyPost(image, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for asciify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageTextAsciifyGet(options?: any) {
            return ImageTextAsciifyApiFp(configuration).getVersionsImageTextAsciifyGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageTextAsciifyApi - object-oriented interface
 * @export
 * @class ImageTextAsciifyApi
 * @extends {BaseAPI}
 */
export class ImageTextAsciifyApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the asciify task for a given models
     * @param {any} image 
     * @param {'ramesh-aditya'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageTextAsciifyApi
     */
    public applyImageTextAsciifyPost(image: any, model?: 'ramesh-aditya', options?: any) {
        return ImageTextAsciifyApiFp(this.configuration).applyImageTextAsciifyPost(image, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for asciify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageTextAsciifyApi
     */
    public getVersionsImageTextAsciifyGet(options?: any) {
        return ImageTextAsciifyApiFp(this.configuration).getVersionsImageTextAsciifyGet(options)(this.axios, this.basePath);
    }

}


/**
 * ImageTextOcrApi - axios parameter creator
 * @export
 */
export const ImageTextOcrApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the ocr task for a given models
         * @param {any} image 
         * @param {string} [sourceLanguage] 
         * @param {'tesseract-denoising' | 'easy-ocr' | 'tesseract-default'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageTextOcrPost(image: any, sourceLanguage?: string, model?: 'tesseract-denoising' | 'easy-ocr' | 'tesseract-default', options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageTextOcrPost.');
            }
            const localVarPath = `/image/text/ocr/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (sourceLanguage !== undefined) {
                localVarQueryParameter['source_language'] = sourceLanguage;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for ocr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageTextOcrGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/text/ocr/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageTextOcrApi - functional programming interface
 * @export
 */
export const ImageTextOcrApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the ocr task for a given models
         * @param {any} image 
         * @param {string} [sourceLanguage] 
         * @param {'tesseract-denoising' | 'easy-ocr' | 'tesseract-default'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageTextOcrPost(image: any, sourceLanguage?: string, model?: 'tesseract-denoising' | 'easy-ocr' | 'tesseract-default', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageTextOcrApiAxiosParamCreator(configuration).applyImageTextOcrPost(image, sourceLanguage, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for ocr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageTextOcrGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageTextOcrApiAxiosParamCreator(configuration).getVersionsImageTextOcrGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageTextOcrApi - factory interface
 * @export
 */
export const ImageTextOcrApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the ocr task for a given models
         * @param {any} image 
         * @param {string} [sourceLanguage] 
         * @param {'tesseract-denoising' | 'easy-ocr' | 'tesseract-default'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageTextOcrPost(image: any, sourceLanguage?: string, model?: 'tesseract-denoising' | 'easy-ocr' | 'tesseract-default', options?: any) {
            return ImageTextOcrApiFp(configuration).applyImageTextOcrPost(image, sourceLanguage, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for ocr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageTextOcrGet(options?: any) {
            return ImageTextOcrApiFp(configuration).getVersionsImageTextOcrGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageTextOcrApi - object-oriented interface
 * @export
 * @class ImageTextOcrApi
 * @extends {BaseAPI}
 */
export class ImageTextOcrApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the ocr task for a given models
     * @param {any} image 
     * @param {string} [sourceLanguage] 
     * @param {'tesseract-denoising' | 'easy-ocr' | 'tesseract-default'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageTextOcrApi
     */
    public applyImageTextOcrPost(image: any, sourceLanguage?: string, model?: 'tesseract-denoising' | 'easy-ocr' | 'tesseract-default', options?: any) {
        return ImageTextOcrApiFp(this.configuration).applyImageTextOcrPost(image, sourceLanguage, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for ocr
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageTextOcrApi
     */
    public getVersionsImageTextOcrGet(options?: any) {
        return ImageTextOcrApiFp(this.configuration).getVersionsImageTextOcrGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextAutocorrectApi - axios parameter creator
 * @export
 */
export const TextTextAutocorrectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the autocorrect task for a given models
         * @param {string} [sentence] 
         * @param {'flexudy-t5-base-multi-sentence-doctor'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextAutocorrectPost(sentence?: string, model?: 'flexudy-t5-base-multi-sentence-doctor', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/autocorrect/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sentence !== undefined) {
                localVarQueryParameter['sentence'] = sentence;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for autocorrect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextAutocorrectGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/autocorrect/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextAutocorrectApi - functional programming interface
 * @export
 */
export const TextTextAutocorrectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the autocorrect task for a given models
         * @param {string} [sentence] 
         * @param {'flexudy-t5-base-multi-sentence-doctor'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextAutocorrectPost(sentence?: string, model?: 'flexudy-t5-base-multi-sentence-doctor', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextAutocorrectApiAxiosParamCreator(configuration).applyTextTextAutocorrectPost(sentence, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for autocorrect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextAutocorrectGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextAutocorrectApiAxiosParamCreator(configuration).getVersionsTextTextAutocorrectGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextAutocorrectApi - factory interface
 * @export
 */
export const TextTextAutocorrectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the autocorrect task for a given models
         * @param {string} [sentence] 
         * @param {'flexudy-t5-base-multi-sentence-doctor'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextAutocorrectPost(sentence?: string, model?: 'flexudy-t5-base-multi-sentence-doctor', options?: any) {
            return TextTextAutocorrectApiFp(configuration).applyTextTextAutocorrectPost(sentence, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for autocorrect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextAutocorrectGet(options?: any) {
            return TextTextAutocorrectApiFp(configuration).getVersionsTextTextAutocorrectGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextAutocorrectApi - object-oriented interface
 * @export
 * @class TextTextAutocorrectApi
 * @extends {BaseAPI}
 */
export class TextTextAutocorrectApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the autocorrect task for a given models
     * @param {string} [sentence] 
     * @param {'flexudy-t5-base-multi-sentence-doctor'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextAutocorrectApi
     */
    public applyTextTextAutocorrectPost(sentence?: string, model?: 'flexudy-t5-base-multi-sentence-doctor', options?: any) {
        return TextTextAutocorrectApiFp(this.configuration).applyTextTextAutocorrectPost(sentence, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for autocorrect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextAutocorrectApi
     */
    public getVersionsTextTextAutocorrectGet(options?: any) {
        return TextTextAutocorrectApiFp(this.configuration).getVersionsTextTextAutocorrectGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextEmotionRecognitionApi - axios parameter creator
 * @export
 */
export const TextTextEmotionRecognitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the emotion-recognition task for a given models
         * @param {string} [text] 
         * @param {'mrm8488-t5-base-finetuned-emotion'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextEmotionRecognitionPost(text?: string, model?: 'mrm8488-t5-base-finetuned-emotion', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/emotion-recognition/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for emotion-recognition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextEmotionRecognitionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/emotion-recognition/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextEmotionRecognitionApi - functional programming interface
 * @export
 */
export const TextTextEmotionRecognitionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the emotion-recognition task for a given models
         * @param {string} [text] 
         * @param {'mrm8488-t5-base-finetuned-emotion'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextEmotionRecognitionPost(text?: string, model?: 'mrm8488-t5-base-finetuned-emotion', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextEmotionRecognitionApiAxiosParamCreator(configuration).applyTextTextEmotionRecognitionPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for emotion-recognition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextEmotionRecognitionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextEmotionRecognitionApiAxiosParamCreator(configuration).getVersionsTextTextEmotionRecognitionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextEmotionRecognitionApi - factory interface
 * @export
 */
export const TextTextEmotionRecognitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the emotion-recognition task for a given models
         * @param {string} [text] 
         * @param {'mrm8488-t5-base-finetuned-emotion'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextEmotionRecognitionPost(text?: string, model?: 'mrm8488-t5-base-finetuned-emotion', options?: any) {
            return TextTextEmotionRecognitionApiFp(configuration).applyTextTextEmotionRecognitionPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for emotion-recognition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextEmotionRecognitionGet(options?: any) {
            return TextTextEmotionRecognitionApiFp(configuration).getVersionsTextTextEmotionRecognitionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextEmotionRecognitionApi - object-oriented interface
 * @export
 * @class TextTextEmotionRecognitionApi
 * @extends {BaseAPI}
 */
export class TextTextEmotionRecognitionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the emotion-recognition task for a given models
     * @param {string} [text] 
     * @param {'mrm8488-t5-base-finetuned-emotion'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextEmotionRecognitionApi
     */
    public applyTextTextEmotionRecognitionPost(text?: string, model?: 'mrm8488-t5-base-finetuned-emotion', options?: any) {
        return TextTextEmotionRecognitionApiFp(this.configuration).applyTextTextEmotionRecognitionPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for emotion-recognition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextEmotionRecognitionApi
     */
    public getVersionsTextTextEmotionRecognitionGet(options?: any) {
        return TextTextEmotionRecognitionApiFp(this.configuration).getVersionsTextTextEmotionRecognitionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextEntityExtractionApi - axios parameter creator
 * @export
 */
export const TextTextEntityExtractionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the entity-extraction task for a given models
         * @param {string} [inputString] 
         * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextEntityExtractionPost(inputString?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/entity-extraction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (inputString !== undefined) {
                localVarQueryParameter['input_string'] = inputString;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for entity-extraction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextEntityExtractionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/entity-extraction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextEntityExtractionApi - functional programming interface
 * @export
 */
export const TextTextEntityExtractionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the entity-extraction task for a given models
         * @param {string} [inputString] 
         * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextEntityExtractionPost(inputString?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextEntityExtractionApiAxiosParamCreator(configuration).applyTextTextEntityExtractionPost(inputString, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for entity-extraction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextEntityExtractionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextEntityExtractionApiAxiosParamCreator(configuration).getVersionsTextTextEntityExtractionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextEntityExtractionApi - factory interface
 * @export
 */
export const TextTextEntityExtractionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the entity-extraction task for a given models
         * @param {string} [inputString] 
         * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextEntityExtractionPost(inputString?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options?: any) {
            return TextTextEntityExtractionApiFp(configuration).applyTextTextEntityExtractionPost(inputString, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for entity-extraction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextEntityExtractionGet(options?: any) {
            return TextTextEntityExtractionApiFp(configuration).getVersionsTextTextEntityExtractionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextEntityExtractionApi - object-oriented interface
 * @export
 * @class TextTextEntityExtractionApi
 * @extends {BaseAPI}
 */
export class TextTextEntityExtractionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the entity-extraction task for a given models
     * @param {string} [inputString] 
     * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextEntityExtractionApi
     */
    public applyTextTextEntityExtractionPost(inputString?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options?: any) {
        return TextTextEntityExtractionApiFp(this.configuration).applyTextTextEntityExtractionPost(inputString, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for entity-extraction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextEntityExtractionApi
     */
    public getVersionsTextTextEntityExtractionGet(options?: any) {
        return TextTextEntityExtractionApiFp(this.configuration).getVersionsTextTextEntityExtractionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextHateSpeechDetectionApi - axios parameter creator
 * @export
 */
export const TextTextHateSpeechDetectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the hate-speech-detection task for a given models
         * @param {string} [text] 
         * @param {'Hate-speech-CNERG-dehatebert-mono-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextHateSpeechDetectionPost(text?: string, model?: 'Hate-speech-CNERG-dehatebert-mono-english', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/hate-speech-detection/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for hate-speech-detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextHateSpeechDetectionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/hate-speech-detection/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextHateSpeechDetectionApi - functional programming interface
 * @export
 */
export const TextTextHateSpeechDetectionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the hate-speech-detection task for a given models
         * @param {string} [text] 
         * @param {'Hate-speech-CNERG-dehatebert-mono-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextHateSpeechDetectionPost(text?: string, model?: 'Hate-speech-CNERG-dehatebert-mono-english', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextHateSpeechDetectionApiAxiosParamCreator(configuration).applyTextTextHateSpeechDetectionPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for hate-speech-detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextHateSpeechDetectionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextHateSpeechDetectionApiAxiosParamCreator(configuration).getVersionsTextTextHateSpeechDetectionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextHateSpeechDetectionApi - factory interface
 * @export
 */
export const TextTextHateSpeechDetectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the hate-speech-detection task for a given models
         * @param {string} [text] 
         * @param {'Hate-speech-CNERG-dehatebert-mono-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextHateSpeechDetectionPost(text?: string, model?: 'Hate-speech-CNERG-dehatebert-mono-english', options?: any) {
            return TextTextHateSpeechDetectionApiFp(configuration).applyTextTextHateSpeechDetectionPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for hate-speech-detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextHateSpeechDetectionGet(options?: any) {
            return TextTextHateSpeechDetectionApiFp(configuration).getVersionsTextTextHateSpeechDetectionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextHateSpeechDetectionApi - object-oriented interface
 * @export
 * @class TextTextHateSpeechDetectionApi
 * @extends {BaseAPI}
 */
export class TextTextHateSpeechDetectionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the hate-speech-detection task for a given models
     * @param {string} [text] 
     * @param {'Hate-speech-CNERG-dehatebert-mono-english'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextHateSpeechDetectionApi
     */
    public applyTextTextHateSpeechDetectionPost(text?: string, model?: 'Hate-speech-CNERG-dehatebert-mono-english', options?: any) {
        return TextTextHateSpeechDetectionApiFp(this.configuration).applyTextTextHateSpeechDetectionPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for hate-speech-detection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextHateSpeechDetectionApi
     */
    public getVersionsTextTextHateSpeechDetectionGet(options?: any) {
        return TextTextHateSpeechDetectionApiFp(this.configuration).getVersionsTextTextHateSpeechDetectionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextKeywordExtractionApi - axios parameter creator
 * @export
 */
export const TextTextKeywordExtractionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the keyword-extraction task for a given models
         * @param {string} [text] 
         * @param {'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextKeywordExtractionPost(text?: string, model?: 'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/keyword-extraction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for keyword-extraction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextKeywordExtractionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/keyword-extraction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextKeywordExtractionApi - functional programming interface
 * @export
 */
export const TextTextKeywordExtractionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the keyword-extraction task for a given models
         * @param {string} [text] 
         * @param {'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextKeywordExtractionPost(text?: string, model?: 'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextKeywordExtractionApiAxiosParamCreator(configuration).applyTextTextKeywordExtractionPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for keyword-extraction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextKeywordExtractionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextKeywordExtractionApiAxiosParamCreator(configuration).getVersionsTextTextKeywordExtractionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextKeywordExtractionApi - factory interface
 * @export
 */
export const TextTextKeywordExtractionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the keyword-extraction task for a given models
         * @param {string} [text] 
         * @param {'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextKeywordExtractionPost(text?: string, model?: 'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2', options?: any) {
            return TextTextKeywordExtractionApiFp(configuration).applyTextTextKeywordExtractionPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for keyword-extraction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextKeywordExtractionGet(options?: any) {
            return TextTextKeywordExtractionApiFp(configuration).getVersionsTextTextKeywordExtractionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextKeywordExtractionApi - object-oriented interface
 * @export
 * @class TextTextKeywordExtractionApi
 * @extends {BaseAPI}
 */
export class TextTextKeywordExtractionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the keyword-extraction task for a given models
     * @param {string} [text] 
     * @param {'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextKeywordExtractionApi
     */
    public applyTextTextKeywordExtractionPost(text?: string, model?: 'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2', options?: any) {
        return TextTextKeywordExtractionApiFp(this.configuration).applyTextTextKeywordExtractionPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for keyword-extraction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextKeywordExtractionApi
     */
    public getVersionsTextTextKeywordExtractionGet(options?: any) {
        return TextTextKeywordExtractionApiFp(this.configuration).getVersionsTextTextKeywordExtractionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextLanguageDetectionApi - axios parameter creator
 * @export
 */
export const TextTextLanguageDetectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the language-detection task for a given models
         * @param {string} [text] 
         * @param {'toftrup-etal-2021'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLanguageDetectionPost(text?: string, model?: 'toftrup-etal-2021', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/language-detection/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for language-detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageDetectionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/language-detection/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextLanguageDetectionApi - functional programming interface
 * @export
 */
export const TextTextLanguageDetectionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the language-detection task for a given models
         * @param {string} [text] 
         * @param {'toftrup-etal-2021'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLanguageDetectionPost(text?: string, model?: 'toftrup-etal-2021', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextLanguageDetectionApiAxiosParamCreator(configuration).applyTextTextLanguageDetectionPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for language-detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageDetectionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextLanguageDetectionApiAxiosParamCreator(configuration).getVersionsTextTextLanguageDetectionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextLanguageDetectionApi - factory interface
 * @export
 */
export const TextTextLanguageDetectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the language-detection task for a given models
         * @param {string} [text] 
         * @param {'toftrup-etal-2021'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLanguageDetectionPost(text?: string, model?: 'toftrup-etal-2021', options?: any) {
            return TextTextLanguageDetectionApiFp(configuration).applyTextTextLanguageDetectionPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for language-detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageDetectionGet(options?: any) {
            return TextTextLanguageDetectionApiFp(configuration).getVersionsTextTextLanguageDetectionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextLanguageDetectionApi - object-oriented interface
 * @export
 * @class TextTextLanguageDetectionApi
 * @extends {BaseAPI}
 */
export class TextTextLanguageDetectionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the language-detection task for a given models
     * @param {string} [text] 
     * @param {'toftrup-etal-2021'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextLanguageDetectionApi
     */
    public applyTextTextLanguageDetectionPost(text?: string, model?: 'toftrup-etal-2021', options?: any) {
        return TextTextLanguageDetectionApiFp(this.configuration).applyTextTextLanguageDetectionPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for language-detection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextLanguageDetectionApi
     */
    public getVersionsTextTextLanguageDetectionGet(options?: any) {
        return TextTextLanguageDetectionApiFp(this.configuration).getVersionsTextTextLanguageDetectionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextLanguageGenerationApi - axios parameter creator
 * @export
 */
export const TextTextLanguageGenerationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the language-generation task for a given models
         * @param {string} [text] 
         * @param {'EleutherAI-gpt-neo-2_7B'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLanguageGenerationPost(text?: string, model?: 'EleutherAI-gpt-neo-2_7B', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/language-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for language-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageGenerationGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/language-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextLanguageGenerationApi - functional programming interface
 * @export
 */
export const TextTextLanguageGenerationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the language-generation task for a given models
         * @param {string} [text] 
         * @param {'EleutherAI-gpt-neo-2_7B'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLanguageGenerationPost(text?: string, model?: 'EleutherAI-gpt-neo-2_7B', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextLanguageGenerationApiAxiosParamCreator(configuration).applyTextTextLanguageGenerationPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for language-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageGenerationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextLanguageGenerationApiAxiosParamCreator(configuration).getVersionsTextTextLanguageGenerationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextLanguageGenerationApi - factory interface
 * @export
 */
export const TextTextLanguageGenerationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the language-generation task for a given models
         * @param {string} [text] 
         * @param {'EleutherAI-gpt-neo-2_7B'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLanguageGenerationPost(text?: string, model?: 'EleutherAI-gpt-neo-2_7B', options?: any) {
            return TextTextLanguageGenerationApiFp(configuration).applyTextTextLanguageGenerationPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for language-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageGenerationGet(options?: any) {
            return TextTextLanguageGenerationApiFp(configuration).getVersionsTextTextLanguageGenerationGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextLanguageGenerationApi - object-oriented interface
 * @export
 * @class TextTextLanguageGenerationApi
 * @extends {BaseAPI}
 */
export class TextTextLanguageGenerationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the language-generation task for a given models
     * @param {string} [text] 
     * @param {'EleutherAI-gpt-neo-2_7B'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextLanguageGenerationApi
     */
    public applyTextTextLanguageGenerationPost(text?: string, model?: 'EleutherAI-gpt-neo-2_7B', options?: any) {
        return TextTextLanguageGenerationApiFp(this.configuration).applyTextTextLanguageGenerationPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for language-generation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextLanguageGenerationApi
     */
    public getVersionsTextTextLanguageGenerationGet(options?: any) {
        return TextTextLanguageGenerationApiFp(this.configuration).getVersionsTextTextLanguageGenerationGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextLemmatizationApi - axios parameter creator
 * @export
 */
export const TextTextLemmatizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the lemmatization task for a given models
         * @param {string} [sentence] 
         * @param {'wordnet'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLemmatizationPost(sentence?: string, model?: 'wordnet', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/lemmatization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sentence !== undefined) {
                localVarQueryParameter['sentence'] = sentence;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for lemmatization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLemmatizationGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/lemmatization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextLemmatizationApi - functional programming interface
 * @export
 */
export const TextTextLemmatizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the lemmatization task for a given models
         * @param {string} [sentence] 
         * @param {'wordnet'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLemmatizationPost(sentence?: string, model?: 'wordnet', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextLemmatizationApiAxiosParamCreator(configuration).applyTextTextLemmatizationPost(sentence, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for lemmatization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLemmatizationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextLemmatizationApiAxiosParamCreator(configuration).getVersionsTextTextLemmatizationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextLemmatizationApi - factory interface
 * @export
 */
export const TextTextLemmatizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the lemmatization task for a given models
         * @param {string} [sentence] 
         * @param {'wordnet'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLemmatizationPost(sentence?: string, model?: 'wordnet', options?: any) {
            return TextTextLemmatizationApiFp(configuration).applyTextTextLemmatizationPost(sentence, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for lemmatization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLemmatizationGet(options?: any) {
            return TextTextLemmatizationApiFp(configuration).getVersionsTextTextLemmatizationGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextLemmatizationApi - object-oriented interface
 * @export
 * @class TextTextLemmatizationApi
 * @extends {BaseAPI}
 */
export class TextTextLemmatizationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the lemmatization task for a given models
     * @param {string} [sentence] 
     * @param {'wordnet'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextLemmatizationApi
     */
    public applyTextTextLemmatizationPost(sentence?: string, model?: 'wordnet', options?: any) {
        return TextTextLemmatizationApiFp(this.configuration).applyTextTextLemmatizationPost(sentence, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for lemmatization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextLemmatizationApi
     */
    public getVersionsTextTextLemmatizationGet(options?: any) {
        return TextTextLemmatizationApiFp(this.configuration).getVersionsTextTextLemmatizationGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextNamedEntityRecognitionApi - axios parameter creator
 * @export
 */
export const TextTextNamedEntityRecognitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the named-entity-recognition task for a given models
         * @param {string} [text] 
         * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNamedEntityRecognitionPost(text?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/named-entity-recognition/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for named-entity-recognition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNamedEntityRecognitionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/named-entity-recognition/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextNamedEntityRecognitionApi - functional programming interface
 * @export
 */
export const TextTextNamedEntityRecognitionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the named-entity-recognition task for a given models
         * @param {string} [text] 
         * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNamedEntityRecognitionPost(text?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextNamedEntityRecognitionApiAxiosParamCreator(configuration).applyTextTextNamedEntityRecognitionPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for named-entity-recognition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNamedEntityRecognitionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextNamedEntityRecognitionApiAxiosParamCreator(configuration).getVersionsTextTextNamedEntityRecognitionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextNamedEntityRecognitionApi - factory interface
 * @export
 */
export const TextTextNamedEntityRecognitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the named-entity-recognition task for a given models
         * @param {string} [text] 
         * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNamedEntityRecognitionPost(text?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options?: any) {
            return TextTextNamedEntityRecognitionApiFp(configuration).applyTextTextNamedEntityRecognitionPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for named-entity-recognition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNamedEntityRecognitionGet(options?: any) {
            return TextTextNamedEntityRecognitionApiFp(configuration).getVersionsTextTextNamedEntityRecognitionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextNamedEntityRecognitionApi - object-oriented interface
 * @export
 * @class TextTextNamedEntityRecognitionApi
 * @extends {BaseAPI}
 */
export class TextTextNamedEntityRecognitionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the named-entity-recognition task for a given models
     * @param {string} [text] 
     * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextNamedEntityRecognitionApi
     */
    public applyTextTextNamedEntityRecognitionPost(text?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options?: any) {
        return TextTextNamedEntityRecognitionApiFp(this.configuration).applyTextTextNamedEntityRecognitionPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for named-entity-recognition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextNamedEntityRecognitionApi
     */
    public getVersionsTextTextNamedEntityRecognitionGet(options?: any) {
        return TextTextNamedEntityRecognitionApiFp(this.configuration).getVersionsTextTextNamedEntityRecognitionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextNextSentencePredictionApi - axios parameter creator
 * @export
 */
export const TextTextNextSentencePredictionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the next-sentence-prediction task for a given models
         * @param {string} [sentence1] 
         * @param {string} [sentence2] 
         * @param {'bert-base-uncased'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNextSentencePredictionPost(sentence1?: string, sentence2?: string, model?: 'bert-base-uncased', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/next-sentence-prediction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sentence1 !== undefined) {
                localVarQueryParameter['sentence_1'] = sentence1;
            }

            if (sentence2 !== undefined) {
                localVarQueryParameter['sentence_2'] = sentence2;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for next-sentence-prediction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNextSentencePredictionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/next-sentence-prediction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextNextSentencePredictionApi - functional programming interface
 * @export
 */
export const TextTextNextSentencePredictionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the next-sentence-prediction task for a given models
         * @param {string} [sentence1] 
         * @param {string} [sentence2] 
         * @param {'bert-base-uncased'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNextSentencePredictionPost(sentence1?: string, sentence2?: string, model?: 'bert-base-uncased', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextNextSentencePredictionApiAxiosParamCreator(configuration).applyTextTextNextSentencePredictionPost(sentence1, sentence2, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for next-sentence-prediction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNextSentencePredictionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextNextSentencePredictionApiAxiosParamCreator(configuration).getVersionsTextTextNextSentencePredictionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextNextSentencePredictionApi - factory interface
 * @export
 */
export const TextTextNextSentencePredictionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the next-sentence-prediction task for a given models
         * @param {string} [sentence1] 
         * @param {string} [sentence2] 
         * @param {'bert-base-uncased'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNextSentencePredictionPost(sentence1?: string, sentence2?: string, model?: 'bert-base-uncased', options?: any) {
            return TextTextNextSentencePredictionApiFp(configuration).applyTextTextNextSentencePredictionPost(sentence1, sentence2, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for next-sentence-prediction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNextSentencePredictionGet(options?: any) {
            return TextTextNextSentencePredictionApiFp(configuration).getVersionsTextTextNextSentencePredictionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextNextSentencePredictionApi - object-oriented interface
 * @export
 * @class TextTextNextSentencePredictionApi
 * @extends {BaseAPI}
 */
export class TextTextNextSentencePredictionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the next-sentence-prediction task for a given models
     * @param {string} [sentence1] 
     * @param {string} [sentence2] 
     * @param {'bert-base-uncased'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextNextSentencePredictionApi
     */
    public applyTextTextNextSentencePredictionPost(sentence1?: string, sentence2?: string, model?: 'bert-base-uncased', options?: any) {
        return TextTextNextSentencePredictionApiFp(this.configuration).applyTextTextNextSentencePredictionPost(sentence1, sentence2, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for next-sentence-prediction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextNextSentencePredictionApi
     */
    public getVersionsTextTextNextSentencePredictionGet(options?: any) {
        return TextTextNextSentencePredictionApiFp(this.configuration).getVersionsTextTextNextSentencePredictionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextNextWordPredictionApi - axios parameter creator
 * @export
 */
export const TextTextNextWordPredictionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the next-word-prediction task for a given models
         * @param {string} [sentence] 
         * @param {'bert-base-uncased' | 'albert-base-v2' | 'distilbert-base-uncased' | 'roberta-base'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNextWordPredictionPost(sentence?: string, model?: 'bert-base-uncased' | 'albert-base-v2' | 'distilbert-base-uncased' | 'roberta-base', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/next-word-prediction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sentence !== undefined) {
                localVarQueryParameter['sentence'] = sentence;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for next-word-prediction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNextWordPredictionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/next-word-prediction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextNextWordPredictionApi - functional programming interface
 * @export
 */
export const TextTextNextWordPredictionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the next-word-prediction task for a given models
         * @param {string} [sentence] 
         * @param {'bert-base-uncased' | 'albert-base-v2' | 'distilbert-base-uncased' | 'roberta-base'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNextWordPredictionPost(sentence?: string, model?: 'bert-base-uncased' | 'albert-base-v2' | 'distilbert-base-uncased' | 'roberta-base', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextNextWordPredictionApiAxiosParamCreator(configuration).applyTextTextNextWordPredictionPost(sentence, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for next-word-prediction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNextWordPredictionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextNextWordPredictionApiAxiosParamCreator(configuration).getVersionsTextTextNextWordPredictionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextNextWordPredictionApi - factory interface
 * @export
 */
export const TextTextNextWordPredictionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the next-word-prediction task for a given models
         * @param {string} [sentence] 
         * @param {'bert-base-uncased' | 'albert-base-v2' | 'distilbert-base-uncased' | 'roberta-base'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNextWordPredictionPost(sentence?: string, model?: 'bert-base-uncased' | 'albert-base-v2' | 'distilbert-base-uncased' | 'roberta-base', options?: any) {
            return TextTextNextWordPredictionApiFp(configuration).applyTextTextNextWordPredictionPost(sentence, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for next-word-prediction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNextWordPredictionGet(options?: any) {
            return TextTextNextWordPredictionApiFp(configuration).getVersionsTextTextNextWordPredictionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextNextWordPredictionApi - object-oriented interface
 * @export
 * @class TextTextNextWordPredictionApi
 * @extends {BaseAPI}
 */
export class TextTextNextWordPredictionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the next-word-prediction task for a given models
     * @param {string} [sentence] 
     * @param {'bert-base-uncased' | 'albert-base-v2' | 'distilbert-base-uncased' | 'roberta-base'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextNextWordPredictionApi
     */
    public applyTextTextNextWordPredictionPost(sentence?: string, model?: 'bert-base-uncased' | 'albert-base-v2' | 'distilbert-base-uncased' | 'roberta-base', options?: any) {
        return TextTextNextWordPredictionApiFp(this.configuration).applyTextTextNextWordPredictionPost(sentence, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for next-word-prediction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextNextWordPredictionApi
     */
    public getVersionsTextTextNextWordPredictionGet(options?: any) {
        return TextTextNextWordPredictionApiFp(this.configuration).getVersionsTextTextNextWordPredictionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextPluralApi - axios parameter creator
 * @export
 */
export const TextTextPluralApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the plural task for a given models
         * @param {string} [word] 
         * @param {number} [count] 
         * @param {'inflect'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextPluralPost(word?: string, count?: number, model?: 'inflect', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/plural/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (word !== undefined) {
                localVarQueryParameter['word'] = word;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for plural
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextPluralGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/plural/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextPluralApi - functional programming interface
 * @export
 */
export const TextTextPluralApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the plural task for a given models
         * @param {string} [word] 
         * @param {number} [count] 
         * @param {'inflect'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextPluralPost(word?: string, count?: number, model?: 'inflect', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextPluralApiAxiosParamCreator(configuration).applyTextTextPluralPost(word, count, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for plural
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextPluralGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextPluralApiAxiosParamCreator(configuration).getVersionsTextTextPluralGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextPluralApi - factory interface
 * @export
 */
export const TextTextPluralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the plural task for a given models
         * @param {string} [word] 
         * @param {number} [count] 
         * @param {'inflect'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextPluralPost(word?: string, count?: number, model?: 'inflect', options?: any) {
            return TextTextPluralApiFp(configuration).applyTextTextPluralPost(word, count, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for plural
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextPluralGet(options?: any) {
            return TextTextPluralApiFp(configuration).getVersionsTextTextPluralGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextPluralApi - object-oriented interface
 * @export
 * @class TextTextPluralApi
 * @extends {BaseAPI}
 */
export class TextTextPluralApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the plural task for a given models
     * @param {string} [word] 
     * @param {number} [count] 
     * @param {'inflect'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextPluralApi
     */
    public applyTextTextPluralPost(word?: string, count?: number, model?: 'inflect', options?: any) {
        return TextTextPluralApiFp(this.configuration).applyTextTextPluralPost(word, count, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for plural
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextPluralApi
     */
    public getVersionsTextTextPluralGet(options?: any) {
        return TextTextPluralApiFp(this.configuration).getVersionsTextTextPluralGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextProgrammingLanguageGenerationApi - axios parameter creator
 * @export
 */
export const TextTextProgrammingLanguageGenerationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the programming-language-generation task for a given models
         * @param {string} [codeSnippet] 
         * @param {'sentdex-GPyT'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextProgrammingLanguageGenerationPost(codeSnippet?: string, model?: 'sentdex-GPyT', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/programming-language-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (codeSnippet !== undefined) {
                localVarQueryParameter['code_snippet'] = codeSnippet;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for programming-language-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextProgrammingLanguageGenerationGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/programming-language-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextProgrammingLanguageGenerationApi - functional programming interface
 * @export
 */
export const TextTextProgrammingLanguageGenerationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the programming-language-generation task for a given models
         * @param {string} [codeSnippet] 
         * @param {'sentdex-GPyT'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextProgrammingLanguageGenerationPost(codeSnippet?: string, model?: 'sentdex-GPyT', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextProgrammingLanguageGenerationApiAxiosParamCreator(configuration).applyTextTextProgrammingLanguageGenerationPost(codeSnippet, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for programming-language-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextProgrammingLanguageGenerationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextProgrammingLanguageGenerationApiAxiosParamCreator(configuration).getVersionsTextTextProgrammingLanguageGenerationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextProgrammingLanguageGenerationApi - factory interface
 * @export
 */
export const TextTextProgrammingLanguageGenerationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the programming-language-generation task for a given models
         * @param {string} [codeSnippet] 
         * @param {'sentdex-GPyT'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextProgrammingLanguageGenerationPost(codeSnippet?: string, model?: 'sentdex-GPyT', options?: any) {
            return TextTextProgrammingLanguageGenerationApiFp(configuration).applyTextTextProgrammingLanguageGenerationPost(codeSnippet, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for programming-language-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextProgrammingLanguageGenerationGet(options?: any) {
            return TextTextProgrammingLanguageGenerationApiFp(configuration).getVersionsTextTextProgrammingLanguageGenerationGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextProgrammingLanguageGenerationApi - object-oriented interface
 * @export
 * @class TextTextProgrammingLanguageGenerationApi
 * @extends {BaseAPI}
 */
export class TextTextProgrammingLanguageGenerationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the programming-language-generation task for a given models
     * @param {string} [codeSnippet] 
     * @param {'sentdex-GPyT'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextProgrammingLanguageGenerationApi
     */
    public applyTextTextProgrammingLanguageGenerationPost(codeSnippet?: string, model?: 'sentdex-GPyT', options?: any) {
        return TextTextProgrammingLanguageGenerationApiFp(this.configuration).applyTextTextProgrammingLanguageGenerationPost(codeSnippet, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for programming-language-generation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextProgrammingLanguageGenerationApi
     */
    public getVersionsTextTextProgrammingLanguageGenerationGet(options?: any) {
        return TextTextProgrammingLanguageGenerationApiFp(this.configuration).getVersionsTextTextProgrammingLanguageGenerationGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextQuestionAnsweringApi - axios parameter creator
 * @export
 */
export const TextTextQuestionAnsweringApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the question-answering task for a given models
         * @param {string} [context] 
         * @param {string} [question] 
         * @param {'mrm8488-bert-tiny-5-finetuned-squadv2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'distilbert-base-cased-distilled-squad' | 'deepset_bert-base-cased-squad2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextQuestionAnsweringPost(context?: string, question?: string, model?: 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'distilbert-base-cased-distilled-squad' | 'deepset_bert-base-cased-squad2', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/question-answering/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (question !== undefined) {
                localVarQueryParameter['question'] = question;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for question-answering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextQuestionAnsweringGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/question-answering/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextQuestionAnsweringApi - functional programming interface
 * @export
 */
export const TextTextQuestionAnsweringApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the question-answering task for a given models
         * @param {string} [context] 
         * @param {string} [question] 
         * @param {'mrm8488-bert-tiny-5-finetuned-squadv2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'distilbert-base-cased-distilled-squad' | 'deepset_bert-base-cased-squad2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextQuestionAnsweringPost(context?: string, question?: string, model?: 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'distilbert-base-cased-distilled-squad' | 'deepset_bert-base-cased-squad2', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextQuestionAnsweringApiAxiosParamCreator(configuration).applyTextTextQuestionAnsweringPost(context, question, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for question-answering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextQuestionAnsweringGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextQuestionAnsweringApiAxiosParamCreator(configuration).getVersionsTextTextQuestionAnsweringGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextQuestionAnsweringApi - factory interface
 * @export
 */
export const TextTextQuestionAnsweringApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the question-answering task for a given models
         * @param {string} [context] 
         * @param {string} [question] 
         * @param {'mrm8488-bert-tiny-5-finetuned-squadv2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'distilbert-base-cased-distilled-squad' | 'deepset_bert-base-cased-squad2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextQuestionAnsweringPost(context?: string, question?: string, model?: 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'distilbert-base-cased-distilled-squad' | 'deepset_bert-base-cased-squad2', options?: any) {
            return TextTextQuestionAnsweringApiFp(configuration).applyTextTextQuestionAnsweringPost(context, question, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for question-answering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextQuestionAnsweringGet(options?: any) {
            return TextTextQuestionAnsweringApiFp(configuration).getVersionsTextTextQuestionAnsweringGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextQuestionAnsweringApi - object-oriented interface
 * @export
 * @class TextTextQuestionAnsweringApi
 * @extends {BaseAPI}
 */
export class TextTextQuestionAnsweringApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the question-answering task for a given models
     * @param {string} [context] 
     * @param {string} [question] 
     * @param {'mrm8488-bert-tiny-5-finetuned-squadv2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'distilbert-base-cased-distilled-squad' | 'deepset_bert-base-cased-squad2'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextQuestionAnsweringApi
     */
    public applyTextTextQuestionAnsweringPost(context?: string, question?: string, model?: 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'distilbert-base-cased-distilled-squad' | 'deepset_bert-base-cased-squad2', options?: any) {
        return TextTextQuestionAnsweringApiFp(this.configuration).applyTextTextQuestionAnsweringPost(context, question, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for question-answering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextQuestionAnsweringApi
     */
    public getVersionsTextTextQuestionAnsweringGet(options?: any) {
        return TextTextQuestionAnsweringApiFp(this.configuration).getVersionsTextTextQuestionAnsweringGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextSentenceParaphraserApi - axios parameter creator
 * @export
 */
export const TextTextSentenceParaphraserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the sentence-paraphraser task for a given models
         * @param {string} [context] 
         * @param {'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentenceParaphraserPost(context?: string, model?: 'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/sentence-paraphraser/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for sentence-paraphraser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentenceParaphraserGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/sentence-paraphraser/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextSentenceParaphraserApi - functional programming interface
 * @export
 */
export const TextTextSentenceParaphraserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the sentence-paraphraser task for a given models
         * @param {string} [context] 
         * @param {'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentenceParaphraserPost(context?: string, model?: 'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSentenceParaphraserApiAxiosParamCreator(configuration).applyTextTextSentenceParaphraserPost(context, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for sentence-paraphraser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentenceParaphraserGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSentenceParaphraserApiAxiosParamCreator(configuration).getVersionsTextTextSentenceParaphraserGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextSentenceParaphraserApi - factory interface
 * @export
 */
export const TextTextSentenceParaphraserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the sentence-paraphraser task for a given models
         * @param {string} [context] 
         * @param {'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentenceParaphraserPost(context?: string, model?: 'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality', options?: any) {
            return TextTextSentenceParaphraserApiFp(configuration).applyTextTextSentenceParaphraserPost(context, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for sentence-paraphraser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentenceParaphraserGet(options?: any) {
            return TextTextSentenceParaphraserApiFp(configuration).getVersionsTextTextSentenceParaphraserGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextSentenceParaphraserApi - object-oriented interface
 * @export
 * @class TextTextSentenceParaphraserApi
 * @extends {BaseAPI}
 */
export class TextTextSentenceParaphraserApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the sentence-paraphraser task for a given models
     * @param {string} [context] 
     * @param {'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSentenceParaphraserApi
     */
    public applyTextTextSentenceParaphraserPost(context?: string, model?: 'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality', options?: any) {
        return TextTextSentenceParaphraserApiFp(this.configuration).applyTextTextSentenceParaphraserPost(context, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for sentence-paraphraser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSentenceParaphraserApi
     */
    public getVersionsTextTextSentenceParaphraserGet(options?: any) {
        return TextTextSentenceParaphraserApiFp(this.configuration).getVersionsTextTextSentenceParaphraserGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextSentimentAnalysisApi - axios parameter creator
 * @export
 */
export const TextTextSentimentAnalysisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the sentiment-analysis task for a given models
         * @param {string} [text] 
         * @param {'zero-shot-classification-facebook-bart-large-mnli' | 'distilbert-base-uncased' | 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased-finetuned-sst-2-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentimentAnalysisPost(text?: string, model?: 'zero-shot-classification-facebook-bart-large-mnli' | 'distilbert-base-uncased' | 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased-finetuned-sst-2-english', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/sentiment-analysis/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for sentiment-analysis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentimentAnalysisGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/sentiment-analysis/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextSentimentAnalysisApi - functional programming interface
 * @export
 */
export const TextTextSentimentAnalysisApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the sentiment-analysis task for a given models
         * @param {string} [text] 
         * @param {'zero-shot-classification-facebook-bart-large-mnli' | 'distilbert-base-uncased' | 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased-finetuned-sst-2-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentimentAnalysisPost(text?: string, model?: 'zero-shot-classification-facebook-bart-large-mnli' | 'distilbert-base-uncased' | 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased-finetuned-sst-2-english', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSentimentAnalysisApiAxiosParamCreator(configuration).applyTextTextSentimentAnalysisPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for sentiment-analysis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentimentAnalysisGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSentimentAnalysisApiAxiosParamCreator(configuration).getVersionsTextTextSentimentAnalysisGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextSentimentAnalysisApi - factory interface
 * @export
 */
export const TextTextSentimentAnalysisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the sentiment-analysis task for a given models
         * @param {string} [text] 
         * @param {'zero-shot-classification-facebook-bart-large-mnli' | 'distilbert-base-uncased' | 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased-finetuned-sst-2-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentimentAnalysisPost(text?: string, model?: 'zero-shot-classification-facebook-bart-large-mnli' | 'distilbert-base-uncased' | 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased-finetuned-sst-2-english', options?: any) {
            return TextTextSentimentAnalysisApiFp(configuration).applyTextTextSentimentAnalysisPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for sentiment-analysis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentimentAnalysisGet(options?: any) {
            return TextTextSentimentAnalysisApiFp(configuration).getVersionsTextTextSentimentAnalysisGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextSentimentAnalysisApi - object-oriented interface
 * @export
 * @class TextTextSentimentAnalysisApi
 * @extends {BaseAPI}
 */
export class TextTextSentimentAnalysisApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the sentiment-analysis task for a given models
     * @param {string} [text] 
     * @param {'zero-shot-classification-facebook-bart-large-mnli' | 'distilbert-base-uncased' | 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased-finetuned-sst-2-english'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSentimentAnalysisApi
     */
    public applyTextTextSentimentAnalysisPost(text?: string, model?: 'zero-shot-classification-facebook-bart-large-mnli' | 'distilbert-base-uncased' | 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased-finetuned-sst-2-english', options?: any) {
        return TextTextSentimentAnalysisApiFp(this.configuration).applyTextTextSentimentAnalysisPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for sentiment-analysis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSentimentAnalysisApi
     */
    public getVersionsTextTextSentimentAnalysisGet(options?: any) {
        return TextTextSentimentAnalysisApiFp(this.configuration).getVersionsTextTextSentimentAnalysisGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextSimilarityApi - axios parameter creator
 * @export
 */
export const TextTextSimilarityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the similarity task for a given models
         * @param {string} [sentence1] 
         * @param {string} [sentence2] 
         * @param {'all-MiniLM-L6-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSimilarityPost(sentence1?: string, sentence2?: string, model?: 'all-MiniLM-L6-v2', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/similarity/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sentence1 !== undefined) {
                localVarQueryParameter['sentence_1'] = sentence1;
            }

            if (sentence2 !== undefined) {
                localVarQueryParameter['sentence_2'] = sentence2;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for similarity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSimilarityGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/similarity/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextSimilarityApi - functional programming interface
 * @export
 */
export const TextTextSimilarityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the similarity task for a given models
         * @param {string} [sentence1] 
         * @param {string} [sentence2] 
         * @param {'all-MiniLM-L6-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSimilarityPost(sentence1?: string, sentence2?: string, model?: 'all-MiniLM-L6-v2', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSimilarityApiAxiosParamCreator(configuration).applyTextTextSimilarityPost(sentence1, sentence2, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for similarity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSimilarityGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSimilarityApiAxiosParamCreator(configuration).getVersionsTextTextSimilarityGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextSimilarityApi - factory interface
 * @export
 */
export const TextTextSimilarityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the similarity task for a given models
         * @param {string} [sentence1] 
         * @param {string} [sentence2] 
         * @param {'all-MiniLM-L6-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSimilarityPost(sentence1?: string, sentence2?: string, model?: 'all-MiniLM-L6-v2', options?: any) {
            return TextTextSimilarityApiFp(configuration).applyTextTextSimilarityPost(sentence1, sentence2, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for similarity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSimilarityGet(options?: any) {
            return TextTextSimilarityApiFp(configuration).getVersionsTextTextSimilarityGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextSimilarityApi - object-oriented interface
 * @export
 * @class TextTextSimilarityApi
 * @extends {BaseAPI}
 */
export class TextTextSimilarityApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the similarity task for a given models
     * @param {string} [sentence1] 
     * @param {string} [sentence2] 
     * @param {'all-MiniLM-L6-v2'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSimilarityApi
     */
    public applyTextTextSimilarityPost(sentence1?: string, sentence2?: string, model?: 'all-MiniLM-L6-v2', options?: any) {
        return TextTextSimilarityApiFp(this.configuration).applyTextTextSimilarityPost(sentence1, sentence2, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for similarity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSimilarityApi
     */
    public getVersionsTextTextSimilarityGet(options?: any) {
        return TextTextSimilarityApiFp(this.configuration).getVersionsTextTextSimilarityGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextWordAlignmentApi - axios parameter creator
 * @export
 */
export const TextTextWordAlignmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the word-alignment task for a given models
         * @param {string} [inputStringLanguage1] 
         * @param {string} [inputStringLanguage2] 
         * @param {'bert-base-multilingual-cased'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextWordAlignmentPost(inputStringLanguage1?: string, inputStringLanguage2?: string, model?: 'bert-base-multilingual-cased', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/word-alignment/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (inputStringLanguage1 !== undefined) {
                localVarQueryParameter['input_string_language_1'] = inputStringLanguage1;
            }

            if (inputStringLanguage2 !== undefined) {
                localVarQueryParameter['input_string_language_2'] = inputStringLanguage2;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for word-alignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextWordAlignmentGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/word-alignment/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextWordAlignmentApi - functional programming interface
 * @export
 */
export const TextTextWordAlignmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the word-alignment task for a given models
         * @param {string} [inputStringLanguage1] 
         * @param {string} [inputStringLanguage2] 
         * @param {'bert-base-multilingual-cased'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextWordAlignmentPost(inputStringLanguage1?: string, inputStringLanguage2?: string, model?: 'bert-base-multilingual-cased', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextWordAlignmentApiAxiosParamCreator(configuration).applyTextTextWordAlignmentPost(inputStringLanguage1, inputStringLanguage2, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for word-alignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextWordAlignmentGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextWordAlignmentApiAxiosParamCreator(configuration).getVersionsTextTextWordAlignmentGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextWordAlignmentApi - factory interface
 * @export
 */
export const TextTextWordAlignmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the word-alignment task for a given models
         * @param {string} [inputStringLanguage1] 
         * @param {string} [inputStringLanguage2] 
         * @param {'bert-base-multilingual-cased'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextWordAlignmentPost(inputStringLanguage1?: string, inputStringLanguage2?: string, model?: 'bert-base-multilingual-cased', options?: any) {
            return TextTextWordAlignmentApiFp(configuration).applyTextTextWordAlignmentPost(inputStringLanguage1, inputStringLanguage2, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for word-alignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextWordAlignmentGet(options?: any) {
            return TextTextWordAlignmentApiFp(configuration).getVersionsTextTextWordAlignmentGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextWordAlignmentApi - object-oriented interface
 * @export
 * @class TextTextWordAlignmentApi
 * @extends {BaseAPI}
 */
export class TextTextWordAlignmentApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the word-alignment task for a given models
     * @param {string} [inputStringLanguage1] 
     * @param {string} [inputStringLanguage2] 
     * @param {'bert-base-multilingual-cased'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextWordAlignmentApi
     */
    public applyTextTextWordAlignmentPost(inputStringLanguage1?: string, inputStringLanguage2?: string, model?: 'bert-base-multilingual-cased', options?: any) {
        return TextTextWordAlignmentApiFp(this.configuration).applyTextTextWordAlignmentPost(inputStringLanguage1, inputStringLanguage2, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for word-alignment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextWordAlignmentApi
     */
    public getVersionsTextTextWordAlignmentGet(options?: any) {
        return TextTextWordAlignmentApiFp(this.configuration).getVersionsTextTextWordAlignmentGet(options)(this.axios, this.basePath);
    }

}


