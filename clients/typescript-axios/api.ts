// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BodyApplyImageImageBackgroundRemovalPost
 */
export interface BodyApplyImageImageBackgroundRemovalPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageBackgroundRemovalPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface BodyApplyImageImageColorizationPost
 */
export interface BodyApplyImageImageColorizationPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageColorizationPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface BodyApplyImageImageFaceBluringPost
 */
export interface BodyApplyImageImageFaceBluringPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageFaceBluringPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface BodyApplyImageImageRestorationPost
 */
export interface BodyApplyImageImageRestorationPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageRestorationPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface BodyApplyImageImageSuperResolutionPost
 */
export interface BodyApplyImageImageSuperResolutionPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageSuperResolutionPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface BodyApplyImageImageUncolorizationPost
 */
export interface BodyApplyImageImageUncolorizationPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageImageUncolorizationPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface BodyApplyImageTextAsciifyPost
 */
export interface BodyApplyImageTextAsciifyPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageTextAsciifyPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface BodyApplyImageTextOcrPost
 */
export interface BodyApplyImageTextOcrPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyImageTextOcrPost
     */
    image: any;
}
/**
 * 
 * @export
 * @interface BodyApplyVideoVideoFrameInterpolationPost
 */
export interface BodyApplyVideoVideoFrameInterpolationPost {
    /**
     * 
     * @type {any}
     * @memberof BodyApplyVideoVideoFrameInterpolationPost
     */
    video: any;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    detail?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<string>}
     * @memberof ValidationError
     */
    loc: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    type: string;
}

/**
 * ImageImageBackgroundRemovalApi - axios parameter creator
 * @export
 */
export const ImageImageBackgroundRemovalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the background-removal task for a given models
         * @param {any} image 
         * @param {'xception' | 'mobilenet'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageBackgroundRemovalPost(image: any, model?: 'xception' | 'mobilenet', options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageBackgroundRemovalPost.');
            }
            const localVarPath = `/image/image/background-removal/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for background-removal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageBackgroundRemovalGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/image/background-removal/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageImageBackgroundRemovalApi - functional programming interface
 * @export
 */
export const ImageImageBackgroundRemovalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the background-removal task for a given models
         * @param {any} image 
         * @param {'xception' | 'mobilenet'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageBackgroundRemovalPost(image: any, model?: 'xception' | 'mobilenet', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageBackgroundRemovalApiAxiosParamCreator(configuration).applyImageImageBackgroundRemovalPost(image, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for background-removal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageBackgroundRemovalGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageBackgroundRemovalApiAxiosParamCreator(configuration).getVersionsImageImageBackgroundRemovalGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageImageBackgroundRemovalApi - factory interface
 * @export
 */
export const ImageImageBackgroundRemovalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the background-removal task for a given models
         * @param {any} image 
         * @param {'xception' | 'mobilenet'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageBackgroundRemovalPost(image: any, model?: 'xception' | 'mobilenet', options?: any) {
            return ImageImageBackgroundRemovalApiFp(configuration).applyImageImageBackgroundRemovalPost(image, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for background-removal
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageBackgroundRemovalGet(options?: any) {
            return ImageImageBackgroundRemovalApiFp(configuration).getVersionsImageImageBackgroundRemovalGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageImageBackgroundRemovalApi - object-oriented interface
 * @export
 * @class ImageImageBackgroundRemovalApi
 * @extends {BaseAPI}
 */
export class ImageImageBackgroundRemovalApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the background-removal task for a given models
     * @param {any} image 
     * @param {'xception' | 'mobilenet'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageBackgroundRemovalApi
     */
    public applyImageImageBackgroundRemovalPost(image: any, model?: 'xception' | 'mobilenet', options?: any) {
        return ImageImageBackgroundRemovalApiFp(this.configuration).applyImageImageBackgroundRemovalPost(image, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for background-removal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageBackgroundRemovalApi
     */
    public getVersionsImageImageBackgroundRemovalGet(options?: any) {
        return ImageImageBackgroundRemovalApiFp(this.configuration).getVersionsImageImageBackgroundRemovalGet(options)(this.axios, this.basePath);
    }

}


/**
 * ImageImageColorizationApi - axios parameter creator
 * @export
 */
export const ImageImageColorizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the colorization task for a given models
         * @param {any} image 
         * @param {'deoldify-artistic' | 'deoldify-stable'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageColorizationPost(image: any, model?: 'deoldify-artistic' | 'deoldify-stable', options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageColorizationPost.');
            }
            const localVarPath = `/image/image/colorization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for colorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageColorizationGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/image/colorization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageImageColorizationApi - functional programming interface
 * @export
 */
export const ImageImageColorizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the colorization task for a given models
         * @param {any} image 
         * @param {'deoldify-artistic' | 'deoldify-stable'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageColorizationPost(image: any, model?: 'deoldify-artistic' | 'deoldify-stable', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageColorizationApiAxiosParamCreator(configuration).applyImageImageColorizationPost(image, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for colorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageColorizationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageColorizationApiAxiosParamCreator(configuration).getVersionsImageImageColorizationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageImageColorizationApi - factory interface
 * @export
 */
export const ImageImageColorizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the colorization task for a given models
         * @param {any} image 
         * @param {'deoldify-artistic' | 'deoldify-stable'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageColorizationPost(image: any, model?: 'deoldify-artistic' | 'deoldify-stable', options?: any) {
            return ImageImageColorizationApiFp(configuration).applyImageImageColorizationPost(image, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for colorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageColorizationGet(options?: any) {
            return ImageImageColorizationApiFp(configuration).getVersionsImageImageColorizationGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageImageColorizationApi - object-oriented interface
 * @export
 * @class ImageImageColorizationApi
 * @extends {BaseAPI}
 */
export class ImageImageColorizationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the colorization task for a given models
     * @param {any} image 
     * @param {'deoldify-artistic' | 'deoldify-stable'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageColorizationApi
     */
    public applyImageImageColorizationPost(image: any, model?: 'deoldify-artistic' | 'deoldify-stable', options?: any) {
        return ImageImageColorizationApiFp(this.configuration).applyImageImageColorizationPost(image, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for colorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageColorizationApi
     */
    public getVersionsImageImageColorizationGet(options?: any) {
        return ImageImageColorizationApiFp(this.configuration).getVersionsImageImageColorizationGet(options)(this.axios, this.basePath);
    }

}


/**
 * ImageImageFaceBluringApi - axios parameter creator
 * @export
 */
export const ImageImageFaceBluringApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the face-bluring task for a given models
         * @param {any} image 
         * @param {'ageitgey'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageFaceBluringPost(image: any, model?: 'ageitgey', options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageFaceBluringPost.');
            }
            const localVarPath = `/image/image/face-bluring/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for face-bluring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageFaceBluringGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/image/face-bluring/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageImageFaceBluringApi - functional programming interface
 * @export
 */
export const ImageImageFaceBluringApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the face-bluring task for a given models
         * @param {any} image 
         * @param {'ageitgey'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageFaceBluringPost(image: any, model?: 'ageitgey', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageFaceBluringApiAxiosParamCreator(configuration).applyImageImageFaceBluringPost(image, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for face-bluring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageFaceBluringGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageFaceBluringApiAxiosParamCreator(configuration).getVersionsImageImageFaceBluringGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageImageFaceBluringApi - factory interface
 * @export
 */
export const ImageImageFaceBluringApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the face-bluring task for a given models
         * @param {any} image 
         * @param {'ageitgey'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageFaceBluringPost(image: any, model?: 'ageitgey', options?: any) {
            return ImageImageFaceBluringApiFp(configuration).applyImageImageFaceBluringPost(image, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for face-bluring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageFaceBluringGet(options?: any) {
            return ImageImageFaceBluringApiFp(configuration).getVersionsImageImageFaceBluringGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageImageFaceBluringApi - object-oriented interface
 * @export
 * @class ImageImageFaceBluringApi
 * @extends {BaseAPI}
 */
export class ImageImageFaceBluringApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the face-bluring task for a given models
     * @param {any} image 
     * @param {'ageitgey'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageFaceBluringApi
     */
    public applyImageImageFaceBluringPost(image: any, model?: 'ageitgey', options?: any) {
        return ImageImageFaceBluringApiFp(this.configuration).applyImageImageFaceBluringPost(image, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for face-bluring
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageFaceBluringApi
     */
    public getVersionsImageImageFaceBluringGet(options?: any) {
        return ImageImageFaceBluringApiFp(this.configuration).getVersionsImageImageFaceBluringGet(options)(this.axios, this.basePath);
    }

}


/**
 * ImageImageRestorationApi - axios parameter creator
 * @export
 */
export const ImageImageRestorationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the restoration task for a given models
         * @param {any} image 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageRestorationPost(image: any, model?: string, options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageRestorationPost.');
            }
            const localVarPath = `/image/image/restoration/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for restoration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageRestorationGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/image/restoration/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageImageRestorationApi - functional programming interface
 * @export
 */
export const ImageImageRestorationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the restoration task for a given models
         * @param {any} image 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageRestorationPost(image: any, model?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageRestorationApiAxiosParamCreator(configuration).applyImageImageRestorationPost(image, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for restoration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageRestorationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageRestorationApiAxiosParamCreator(configuration).getVersionsImageImageRestorationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageImageRestorationApi - factory interface
 * @export
 */
export const ImageImageRestorationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the restoration task for a given models
         * @param {any} image 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageRestorationPost(image: any, model?: string, options?: any) {
            return ImageImageRestorationApiFp(configuration).applyImageImageRestorationPost(image, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for restoration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageRestorationGet(options?: any) {
            return ImageImageRestorationApiFp(configuration).getVersionsImageImageRestorationGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageImageRestorationApi - object-oriented interface
 * @export
 * @class ImageImageRestorationApi
 * @extends {BaseAPI}
 */
export class ImageImageRestorationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the restoration task for a given models
     * @param {any} image 
     * @param {string} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageRestorationApi
     */
    public applyImageImageRestorationPost(image: any, model?: string, options?: any) {
        return ImageImageRestorationApiFp(this.configuration).applyImageImageRestorationPost(image, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for restoration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageRestorationApi
     */
    public getVersionsImageImageRestorationGet(options?: any) {
        return ImageImageRestorationApiFp(this.configuration).getVersionsImageImageRestorationGet(options)(this.axios, this.basePath);
    }

}


/**
 * ImageImageSuperResolutionApi - axios parameter creator
 * @export
 */
export const ImageImageSuperResolutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the super-resolution task for a given models
         * @param {any} image 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageSuperResolutionPost(image: any, model?: string, options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageSuperResolutionPost.');
            }
            const localVarPath = `/image/image/super-resolution/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for super-resolution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageSuperResolutionGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/image/super-resolution/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageImageSuperResolutionApi - functional programming interface
 * @export
 */
export const ImageImageSuperResolutionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the super-resolution task for a given models
         * @param {any} image 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageSuperResolutionPost(image: any, model?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageSuperResolutionApiAxiosParamCreator(configuration).applyImageImageSuperResolutionPost(image, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for super-resolution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageSuperResolutionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageSuperResolutionApiAxiosParamCreator(configuration).getVersionsImageImageSuperResolutionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageImageSuperResolutionApi - factory interface
 * @export
 */
export const ImageImageSuperResolutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the super-resolution task for a given models
         * @param {any} image 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageSuperResolutionPost(image: any, model?: string, options?: any) {
            return ImageImageSuperResolutionApiFp(configuration).applyImageImageSuperResolutionPost(image, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for super-resolution
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageSuperResolutionGet(options?: any) {
            return ImageImageSuperResolutionApiFp(configuration).getVersionsImageImageSuperResolutionGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageImageSuperResolutionApi - object-oriented interface
 * @export
 * @class ImageImageSuperResolutionApi
 * @extends {BaseAPI}
 */
export class ImageImageSuperResolutionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the super-resolution task for a given models
     * @param {any} image 
     * @param {string} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageSuperResolutionApi
     */
    public applyImageImageSuperResolutionPost(image: any, model?: string, options?: any) {
        return ImageImageSuperResolutionApiFp(this.configuration).applyImageImageSuperResolutionPost(image, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for super-resolution
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageSuperResolutionApi
     */
    public getVersionsImageImageSuperResolutionGet(options?: any) {
        return ImageImageSuperResolutionApiFp(this.configuration).getVersionsImageImageSuperResolutionGet(options)(this.axios, this.basePath);
    }

}


/**
 * ImageImageUncolorizationApi - axios parameter creator
 * @export
 */
export const ImageImageUncolorizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the uncolorization task for a given models
         * @param {any} image 
         * @param {'v1'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageUncolorizationPost(image: any, model?: 'v1', options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageImageUncolorizationPost.');
            }
            const localVarPath = `/image/image/uncolorization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for uncolorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageUncolorizationGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/image/uncolorization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageImageUncolorizationApi - functional programming interface
 * @export
 */
export const ImageImageUncolorizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the uncolorization task for a given models
         * @param {any} image 
         * @param {'v1'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageUncolorizationPost(image: any, model?: 'v1', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageUncolorizationApiAxiosParamCreator(configuration).applyImageImageUncolorizationPost(image, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for uncolorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageUncolorizationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageImageUncolorizationApiAxiosParamCreator(configuration).getVersionsImageImageUncolorizationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageImageUncolorizationApi - factory interface
 * @export
 */
export const ImageImageUncolorizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the uncolorization task for a given models
         * @param {any} image 
         * @param {'v1'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageImageUncolorizationPost(image: any, model?: 'v1', options?: any) {
            return ImageImageUncolorizationApiFp(configuration).applyImageImageUncolorizationPost(image, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for uncolorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageImageUncolorizationGet(options?: any) {
            return ImageImageUncolorizationApiFp(configuration).getVersionsImageImageUncolorizationGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageImageUncolorizationApi - object-oriented interface
 * @export
 * @class ImageImageUncolorizationApi
 * @extends {BaseAPI}
 */
export class ImageImageUncolorizationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the uncolorization task for a given models
     * @param {any} image 
     * @param {'v1'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageUncolorizationApi
     */
    public applyImageImageUncolorizationPost(image: any, model?: 'v1', options?: any) {
        return ImageImageUncolorizationApiFp(this.configuration).applyImageImageUncolorizationPost(image, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for uncolorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageImageUncolorizationApi
     */
    public getVersionsImageImageUncolorizationGet(options?: any) {
        return ImageImageUncolorizationApiFp(this.configuration).getVersionsImageImageUncolorizationGet(options)(this.axios, this.basePath);
    }

}


/**
 * ImageTextAsciifyApi - axios parameter creator
 * @export
 */
export const ImageTextAsciifyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the asciify task for a given models
         * @param {any} image 
         * @param {'ramesh-aditya'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageTextAsciifyPost(image: any, model?: 'ramesh-aditya', options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageTextAsciifyPost.');
            }
            const localVarPath = `/image/text/asciify/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for asciify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageTextAsciifyGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/text/asciify/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageTextAsciifyApi - functional programming interface
 * @export
 */
export const ImageTextAsciifyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the asciify task for a given models
         * @param {any} image 
         * @param {'ramesh-aditya'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageTextAsciifyPost(image: any, model?: 'ramesh-aditya', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageTextAsciifyApiAxiosParamCreator(configuration).applyImageTextAsciifyPost(image, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for asciify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageTextAsciifyGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageTextAsciifyApiAxiosParamCreator(configuration).getVersionsImageTextAsciifyGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageTextAsciifyApi - factory interface
 * @export
 */
export const ImageTextAsciifyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the asciify task for a given models
         * @param {any} image 
         * @param {'ramesh-aditya'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageTextAsciifyPost(image: any, model?: 'ramesh-aditya', options?: any) {
            return ImageTextAsciifyApiFp(configuration).applyImageTextAsciifyPost(image, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for asciify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageTextAsciifyGet(options?: any) {
            return ImageTextAsciifyApiFp(configuration).getVersionsImageTextAsciifyGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageTextAsciifyApi - object-oriented interface
 * @export
 * @class ImageTextAsciifyApi
 * @extends {BaseAPI}
 */
export class ImageTextAsciifyApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the asciify task for a given models
     * @param {any} image 
     * @param {'ramesh-aditya'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageTextAsciifyApi
     */
    public applyImageTextAsciifyPost(image: any, model?: 'ramesh-aditya', options?: any) {
        return ImageTextAsciifyApiFp(this.configuration).applyImageTextAsciifyPost(image, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for asciify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageTextAsciifyApi
     */
    public getVersionsImageTextAsciifyGet(options?: any) {
        return ImageTextAsciifyApiFp(this.configuration).getVersionsImageTextAsciifyGet(options)(this.axios, this.basePath);
    }

}


/**
 * ImageTextOcrApi - axios parameter creator
 * @export
 */
export const ImageTextOcrApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the ocr task for a given models
         * @param {any} image 
         * @param {string} [sourceLanguage] 
         * @param {'tesseract-default' | 'tesseract-denoising' | 'easy-ocr'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageTextOcrPost(image: any, sourceLanguage?: string, model?: 'tesseract-default' | 'tesseract-denoising' | 'easy-ocr', options: any = {}): RequestArgs {
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling applyImageTextOcrPost.');
            }
            const localVarPath = `/image/text/ocr/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (sourceLanguage !== undefined) {
                localVarQueryParameter['source_language'] = sourceLanguage;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for ocr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageTextOcrGet(options: any = {}): RequestArgs {
            const localVarPath = `/image/text/ocr/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageTextOcrApi - functional programming interface
 * @export
 */
export const ImageTextOcrApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the ocr task for a given models
         * @param {any} image 
         * @param {string} [sourceLanguage] 
         * @param {'tesseract-default' | 'tesseract-denoising' | 'easy-ocr'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageTextOcrPost(image: any, sourceLanguage?: string, model?: 'tesseract-default' | 'tesseract-denoising' | 'easy-ocr', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageTextOcrApiAxiosParamCreator(configuration).applyImageTextOcrPost(image, sourceLanguage, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for ocr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageTextOcrGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = ImageTextOcrApiAxiosParamCreator(configuration).getVersionsImageTextOcrGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageTextOcrApi - factory interface
 * @export
 */
export const ImageTextOcrApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the ocr task for a given models
         * @param {any} image 
         * @param {string} [sourceLanguage] 
         * @param {'tesseract-default' | 'tesseract-denoising' | 'easy-ocr'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyImageTextOcrPost(image: any, sourceLanguage?: string, model?: 'tesseract-default' | 'tesseract-denoising' | 'easy-ocr', options?: any) {
            return ImageTextOcrApiFp(configuration).applyImageTextOcrPost(image, sourceLanguage, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for ocr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsImageTextOcrGet(options?: any) {
            return ImageTextOcrApiFp(configuration).getVersionsImageTextOcrGet(options)(axios, basePath);
        },
    };
};

/**
 * ImageTextOcrApi - object-oriented interface
 * @export
 * @class ImageTextOcrApi
 * @extends {BaseAPI}
 */
export class ImageTextOcrApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the ocr task for a given models
     * @param {any} image 
     * @param {string} [sourceLanguage] 
     * @param {'tesseract-default' | 'tesseract-denoising' | 'easy-ocr'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageTextOcrApi
     */
    public applyImageTextOcrPost(image: any, sourceLanguage?: string, model?: 'tesseract-default' | 'tesseract-denoising' | 'easy-ocr', options?: any) {
        return ImageTextOcrApiFp(this.configuration).applyImageTextOcrPost(image, sourceLanguage, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for ocr
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageTextOcrApi
     */
    public getVersionsImageTextOcrGet(options?: any) {
        return ImageTextOcrApiFp(this.configuration).getVersionsImageTextOcrGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextAutocorrectApi - axios parameter creator
 * @export
 */
export const TextTextAutocorrectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the autocorrect task for a given models
         * @param {string} [sentence] 
         * @param {'flexudy-t5-base-multi-sentence-doctor'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextAutocorrectPost(sentence?: string, model?: 'flexudy-t5-base-multi-sentence-doctor', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/autocorrect/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sentence !== undefined) {
                localVarQueryParameter['sentence'] = sentence;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for autocorrect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextAutocorrectGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/autocorrect/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextAutocorrectApi - functional programming interface
 * @export
 */
export const TextTextAutocorrectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the autocorrect task for a given models
         * @param {string} [sentence] 
         * @param {'flexudy-t5-base-multi-sentence-doctor'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextAutocorrectPost(sentence?: string, model?: 'flexudy-t5-base-multi-sentence-doctor', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextAutocorrectApiAxiosParamCreator(configuration).applyTextTextAutocorrectPost(sentence, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for autocorrect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextAutocorrectGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextAutocorrectApiAxiosParamCreator(configuration).getVersionsTextTextAutocorrectGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextAutocorrectApi - factory interface
 * @export
 */
export const TextTextAutocorrectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the autocorrect task for a given models
         * @param {string} [sentence] 
         * @param {'flexudy-t5-base-multi-sentence-doctor'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextAutocorrectPost(sentence?: string, model?: 'flexudy-t5-base-multi-sentence-doctor', options?: any) {
            return TextTextAutocorrectApiFp(configuration).applyTextTextAutocorrectPost(sentence, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for autocorrect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextAutocorrectGet(options?: any) {
            return TextTextAutocorrectApiFp(configuration).getVersionsTextTextAutocorrectGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextAutocorrectApi - object-oriented interface
 * @export
 * @class TextTextAutocorrectApi
 * @extends {BaseAPI}
 */
export class TextTextAutocorrectApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the autocorrect task for a given models
     * @param {string} [sentence] 
     * @param {'flexudy-t5-base-multi-sentence-doctor'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextAutocorrectApi
     */
    public applyTextTextAutocorrectPost(sentence?: string, model?: 'flexudy-t5-base-multi-sentence-doctor', options?: any) {
        return TextTextAutocorrectApiFp(this.configuration).applyTextTextAutocorrectPost(sentence, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for autocorrect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextAutocorrectApi
     */
    public getVersionsTextTextAutocorrectGet(options?: any) {
        return TextTextAutocorrectApiFp(this.configuration).getVersionsTextTextAutocorrectGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextBooleanQuestionGenerationApi - axios parameter creator
 * @export
 */
export const TextTextBooleanQuestionGenerationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the boolean-question-generation task for a given models
         * @param {string} [text] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextBooleanQuestionGenerationPost(text?: string, model?: string, options: any = {}): RequestArgs {
            const localVarPath = `/text/text/boolean-question-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for boolean-question-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextBooleanQuestionGenerationGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/boolean-question-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextBooleanQuestionGenerationApi - functional programming interface
 * @export
 */
export const TextTextBooleanQuestionGenerationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the boolean-question-generation task for a given models
         * @param {string} [text] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextBooleanQuestionGenerationPost(text?: string, model?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextBooleanQuestionGenerationApiAxiosParamCreator(configuration).applyTextTextBooleanQuestionGenerationPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for boolean-question-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextBooleanQuestionGenerationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextBooleanQuestionGenerationApiAxiosParamCreator(configuration).getVersionsTextTextBooleanQuestionGenerationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextBooleanQuestionGenerationApi - factory interface
 * @export
 */
export const TextTextBooleanQuestionGenerationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the boolean-question-generation task for a given models
         * @param {string} [text] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextBooleanQuestionGenerationPost(text?: string, model?: string, options?: any) {
            return TextTextBooleanQuestionGenerationApiFp(configuration).applyTextTextBooleanQuestionGenerationPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for boolean-question-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextBooleanQuestionGenerationGet(options?: any) {
            return TextTextBooleanQuestionGenerationApiFp(configuration).getVersionsTextTextBooleanQuestionGenerationGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextBooleanQuestionGenerationApi - object-oriented interface
 * @export
 * @class TextTextBooleanQuestionGenerationApi
 * @extends {BaseAPI}
 */
export class TextTextBooleanQuestionGenerationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the boolean-question-generation task for a given models
     * @param {string} [text] 
     * @param {string} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextBooleanQuestionGenerationApi
     */
    public applyTextTextBooleanQuestionGenerationPost(text?: string, model?: string, options?: any) {
        return TextTextBooleanQuestionGenerationApiFp(this.configuration).applyTextTextBooleanQuestionGenerationPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for boolean-question-generation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextBooleanQuestionGenerationApi
     */
    public getVersionsTextTextBooleanQuestionGenerationGet(options?: any) {
        return TextTextBooleanQuestionGenerationApiFp(this.configuration).getVersionsTextTextBooleanQuestionGenerationGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextDependencyTrackingApi - axios parameter creator
 * @export
 */
export const TextTextDependencyTrackingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the dependency-tracking task for a given models
         * @param {string} [inputString] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextDependencyTrackingPost(inputString?: string, model?: string, options: any = {}): RequestArgs {
            const localVarPath = `/text/text/dependency-tracking/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (inputString !== undefined) {
                localVarQueryParameter['input_string'] = inputString;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for dependency-tracking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextDependencyTrackingGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/dependency-tracking/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextDependencyTrackingApi - functional programming interface
 * @export
 */
export const TextTextDependencyTrackingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the dependency-tracking task for a given models
         * @param {string} [inputString] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextDependencyTrackingPost(inputString?: string, model?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextDependencyTrackingApiAxiosParamCreator(configuration).applyTextTextDependencyTrackingPost(inputString, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for dependency-tracking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextDependencyTrackingGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextDependencyTrackingApiAxiosParamCreator(configuration).getVersionsTextTextDependencyTrackingGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextDependencyTrackingApi - factory interface
 * @export
 */
export const TextTextDependencyTrackingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the dependency-tracking task for a given models
         * @param {string} [inputString] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextDependencyTrackingPost(inputString?: string, model?: string, options?: any) {
            return TextTextDependencyTrackingApiFp(configuration).applyTextTextDependencyTrackingPost(inputString, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for dependency-tracking
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextDependencyTrackingGet(options?: any) {
            return TextTextDependencyTrackingApiFp(configuration).getVersionsTextTextDependencyTrackingGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextDependencyTrackingApi - object-oriented interface
 * @export
 * @class TextTextDependencyTrackingApi
 * @extends {BaseAPI}
 */
export class TextTextDependencyTrackingApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the dependency-tracking task for a given models
     * @param {string} [inputString] 
     * @param {string} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextDependencyTrackingApi
     */
    public applyTextTextDependencyTrackingPost(inputString?: string, model?: string, options?: any) {
        return TextTextDependencyTrackingApiFp(this.configuration).applyTextTextDependencyTrackingPost(inputString, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for dependency-tracking
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextDependencyTrackingApi
     */
    public getVersionsTextTextDependencyTrackingGet(options?: any) {
        return TextTextDependencyTrackingApiFp(this.configuration).getVersionsTextTextDependencyTrackingGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextEmotionRecognitionApi - axios parameter creator
 * @export
 */
export const TextTextEmotionRecognitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the emotion-recognition task for a given models
         * @param {string} [text] 
         * @param {'mrm8488-t5-base-finetuned-emotion'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextEmotionRecognitionPost(text?: string, model?: 'mrm8488-t5-base-finetuned-emotion', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/emotion-recognition/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for emotion-recognition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextEmotionRecognitionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/emotion-recognition/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextEmotionRecognitionApi - functional programming interface
 * @export
 */
export const TextTextEmotionRecognitionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the emotion-recognition task for a given models
         * @param {string} [text] 
         * @param {'mrm8488-t5-base-finetuned-emotion'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextEmotionRecognitionPost(text?: string, model?: 'mrm8488-t5-base-finetuned-emotion', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextEmotionRecognitionApiAxiosParamCreator(configuration).applyTextTextEmotionRecognitionPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for emotion-recognition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextEmotionRecognitionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextEmotionRecognitionApiAxiosParamCreator(configuration).getVersionsTextTextEmotionRecognitionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextEmotionRecognitionApi - factory interface
 * @export
 */
export const TextTextEmotionRecognitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the emotion-recognition task for a given models
         * @param {string} [text] 
         * @param {'mrm8488-t5-base-finetuned-emotion'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextEmotionRecognitionPost(text?: string, model?: 'mrm8488-t5-base-finetuned-emotion', options?: any) {
            return TextTextEmotionRecognitionApiFp(configuration).applyTextTextEmotionRecognitionPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for emotion-recognition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextEmotionRecognitionGet(options?: any) {
            return TextTextEmotionRecognitionApiFp(configuration).getVersionsTextTextEmotionRecognitionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextEmotionRecognitionApi - object-oriented interface
 * @export
 * @class TextTextEmotionRecognitionApi
 * @extends {BaseAPI}
 */
export class TextTextEmotionRecognitionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the emotion-recognition task for a given models
     * @param {string} [text] 
     * @param {'mrm8488-t5-base-finetuned-emotion'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextEmotionRecognitionApi
     */
    public applyTextTextEmotionRecognitionPost(text?: string, model?: 'mrm8488-t5-base-finetuned-emotion', options?: any) {
        return TextTextEmotionRecognitionApiFp(this.configuration).applyTextTextEmotionRecognitionPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for emotion-recognition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextEmotionRecognitionApi
     */
    public getVersionsTextTextEmotionRecognitionGet(options?: any) {
        return TextTextEmotionRecognitionApiFp(this.configuration).getVersionsTextTextEmotionRecognitionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextEntityExtractionApi - axios parameter creator
 * @export
 */
export const TextTextEntityExtractionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the entity-extraction task for a given models
         * @param {string} [inputString] 
         * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextEntityExtractionPost(inputString?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/entity-extraction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (inputString !== undefined) {
                localVarQueryParameter['input_string'] = inputString;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for entity-extraction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextEntityExtractionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/entity-extraction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextEntityExtractionApi - functional programming interface
 * @export
 */
export const TextTextEntityExtractionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the entity-extraction task for a given models
         * @param {string} [inputString] 
         * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextEntityExtractionPost(inputString?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextEntityExtractionApiAxiosParamCreator(configuration).applyTextTextEntityExtractionPost(inputString, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for entity-extraction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextEntityExtractionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextEntityExtractionApiAxiosParamCreator(configuration).getVersionsTextTextEntityExtractionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextEntityExtractionApi - factory interface
 * @export
 */
export const TextTextEntityExtractionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the entity-extraction task for a given models
         * @param {string} [inputString] 
         * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextEntityExtractionPost(inputString?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options?: any) {
            return TextTextEntityExtractionApiFp(configuration).applyTextTextEntityExtractionPost(inputString, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for entity-extraction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextEntityExtractionGet(options?: any) {
            return TextTextEntityExtractionApiFp(configuration).getVersionsTextTextEntityExtractionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextEntityExtractionApi - object-oriented interface
 * @export
 * @class TextTextEntityExtractionApi
 * @extends {BaseAPI}
 */
export class TextTextEntityExtractionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the entity-extraction task for a given models
     * @param {string} [inputString] 
     * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextEntityExtractionApi
     */
    public applyTextTextEntityExtractionPost(inputString?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options?: any) {
        return TextTextEntityExtractionApiFp(this.configuration).applyTextTextEntityExtractionPost(inputString, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for entity-extraction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextEntityExtractionApi
     */
    public getVersionsTextTextEntityExtractionGet(options?: any) {
        return TextTextEntityExtractionApiFp(this.configuration).getVersionsTextTextEntityExtractionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextHateSpeechDetectionApi - axios parameter creator
 * @export
 */
export const TextTextHateSpeechDetectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the hate-speech-detection task for a given models
         * @param {string} [text] 
         * @param {'Hate-speech-CNERG-dehatebert-mono-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextHateSpeechDetectionPost(text?: string, model?: 'Hate-speech-CNERG-dehatebert-mono-english', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/hate-speech-detection/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for hate-speech-detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextHateSpeechDetectionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/hate-speech-detection/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextHateSpeechDetectionApi - functional programming interface
 * @export
 */
export const TextTextHateSpeechDetectionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the hate-speech-detection task for a given models
         * @param {string} [text] 
         * @param {'Hate-speech-CNERG-dehatebert-mono-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextHateSpeechDetectionPost(text?: string, model?: 'Hate-speech-CNERG-dehatebert-mono-english', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextHateSpeechDetectionApiAxiosParamCreator(configuration).applyTextTextHateSpeechDetectionPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for hate-speech-detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextHateSpeechDetectionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextHateSpeechDetectionApiAxiosParamCreator(configuration).getVersionsTextTextHateSpeechDetectionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextHateSpeechDetectionApi - factory interface
 * @export
 */
export const TextTextHateSpeechDetectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the hate-speech-detection task for a given models
         * @param {string} [text] 
         * @param {'Hate-speech-CNERG-dehatebert-mono-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextHateSpeechDetectionPost(text?: string, model?: 'Hate-speech-CNERG-dehatebert-mono-english', options?: any) {
            return TextTextHateSpeechDetectionApiFp(configuration).applyTextTextHateSpeechDetectionPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for hate-speech-detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextHateSpeechDetectionGet(options?: any) {
            return TextTextHateSpeechDetectionApiFp(configuration).getVersionsTextTextHateSpeechDetectionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextHateSpeechDetectionApi - object-oriented interface
 * @export
 * @class TextTextHateSpeechDetectionApi
 * @extends {BaseAPI}
 */
export class TextTextHateSpeechDetectionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the hate-speech-detection task for a given models
     * @param {string} [text] 
     * @param {'Hate-speech-CNERG-dehatebert-mono-english'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextHateSpeechDetectionApi
     */
    public applyTextTextHateSpeechDetectionPost(text?: string, model?: 'Hate-speech-CNERG-dehatebert-mono-english', options?: any) {
        return TextTextHateSpeechDetectionApiFp(this.configuration).applyTextTextHateSpeechDetectionPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for hate-speech-detection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextHateSpeechDetectionApi
     */
    public getVersionsTextTextHateSpeechDetectionGet(options?: any) {
        return TextTextHateSpeechDetectionApiFp(this.configuration).getVersionsTextTextHateSpeechDetectionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextKeywordExtractionApi - axios parameter creator
 * @export
 */
export const TextTextKeywordExtractionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the keyword-extraction task for a given models
         * @param {string} [text] 
         * @param {'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextKeywordExtractionPost(text?: string, model?: 'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/keyword-extraction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for keyword-extraction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextKeywordExtractionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/keyword-extraction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextKeywordExtractionApi - functional programming interface
 * @export
 */
export const TextTextKeywordExtractionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the keyword-extraction task for a given models
         * @param {string} [text] 
         * @param {'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextKeywordExtractionPost(text?: string, model?: 'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextKeywordExtractionApiAxiosParamCreator(configuration).applyTextTextKeywordExtractionPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for keyword-extraction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextKeywordExtractionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextKeywordExtractionApiAxiosParamCreator(configuration).getVersionsTextTextKeywordExtractionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextKeywordExtractionApi - factory interface
 * @export
 */
export const TextTextKeywordExtractionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the keyword-extraction task for a given models
         * @param {string} [text] 
         * @param {'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextKeywordExtractionPost(text?: string, model?: 'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2', options?: any) {
            return TextTextKeywordExtractionApiFp(configuration).applyTextTextKeywordExtractionPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for keyword-extraction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextKeywordExtractionGet(options?: any) {
            return TextTextKeywordExtractionApiFp(configuration).getVersionsTextTextKeywordExtractionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextKeywordExtractionApi - object-oriented interface
 * @export
 * @class TextTextKeywordExtractionApi
 * @extends {BaseAPI}
 */
export class TextTextKeywordExtractionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the keyword-extraction task for a given models
     * @param {string} [text] 
     * @param {'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextKeywordExtractionApi
     */
    public applyTextTextKeywordExtractionPost(text?: string, model?: 'keybert-paraphrase-MiniLM-L6-v2' | 'keybert-paraphrase-multilingual-MiniLM-L12-v2', options?: any) {
        return TextTextKeywordExtractionApiFp(this.configuration).applyTextTextKeywordExtractionPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for keyword-extraction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextKeywordExtractionApi
     */
    public getVersionsTextTextKeywordExtractionGet(options?: any) {
        return TextTextKeywordExtractionApiFp(this.configuration).getVersionsTextTextKeywordExtractionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextLanguageDetectionApi - axios parameter creator
 * @export
 */
export const TextTextLanguageDetectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the language-detection task for a given models
         * @param {string} [text] 
         * @param {'toftrup-etal-2021'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLanguageDetectionPost(text?: string, model?: 'toftrup-etal-2021', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/language-detection/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for language-detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageDetectionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/language-detection/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextLanguageDetectionApi - functional programming interface
 * @export
 */
export const TextTextLanguageDetectionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the language-detection task for a given models
         * @param {string} [text] 
         * @param {'toftrup-etal-2021'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLanguageDetectionPost(text?: string, model?: 'toftrup-etal-2021', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextLanguageDetectionApiAxiosParamCreator(configuration).applyTextTextLanguageDetectionPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for language-detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageDetectionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextLanguageDetectionApiAxiosParamCreator(configuration).getVersionsTextTextLanguageDetectionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextLanguageDetectionApi - factory interface
 * @export
 */
export const TextTextLanguageDetectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the language-detection task for a given models
         * @param {string} [text] 
         * @param {'toftrup-etal-2021'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLanguageDetectionPost(text?: string, model?: 'toftrup-etal-2021', options?: any) {
            return TextTextLanguageDetectionApiFp(configuration).applyTextTextLanguageDetectionPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for language-detection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageDetectionGet(options?: any) {
            return TextTextLanguageDetectionApiFp(configuration).getVersionsTextTextLanguageDetectionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextLanguageDetectionApi - object-oriented interface
 * @export
 * @class TextTextLanguageDetectionApi
 * @extends {BaseAPI}
 */
export class TextTextLanguageDetectionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the language-detection task for a given models
     * @param {string} [text] 
     * @param {'toftrup-etal-2021'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextLanguageDetectionApi
     */
    public applyTextTextLanguageDetectionPost(text?: string, model?: 'toftrup-etal-2021', options?: any) {
        return TextTextLanguageDetectionApiFp(this.configuration).applyTextTextLanguageDetectionPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for language-detection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextLanguageDetectionApi
     */
    public getVersionsTextTextLanguageDetectionGet(options?: any) {
        return TextTextLanguageDetectionApiFp(this.configuration).getVersionsTextTextLanguageDetectionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextLanguageGenerationApi - axios parameter creator
 * @export
 */
export const TextTextLanguageGenerationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the language-generation task for a given models
         * @param {string} [text] 
         * @param {'EleutherAI-gpt-neo-2_7B'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLanguageGenerationPost(text?: string, model?: 'EleutherAI-gpt-neo-2_7B', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/language-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for language-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageGenerationGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/language-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextLanguageGenerationApi - functional programming interface
 * @export
 */
export const TextTextLanguageGenerationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the language-generation task for a given models
         * @param {string} [text] 
         * @param {'EleutherAI-gpt-neo-2_7B'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLanguageGenerationPost(text?: string, model?: 'EleutherAI-gpt-neo-2_7B', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextLanguageGenerationApiAxiosParamCreator(configuration).applyTextTextLanguageGenerationPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for language-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageGenerationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextLanguageGenerationApiAxiosParamCreator(configuration).getVersionsTextTextLanguageGenerationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextLanguageGenerationApi - factory interface
 * @export
 */
export const TextTextLanguageGenerationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the language-generation task for a given models
         * @param {string} [text] 
         * @param {'EleutherAI-gpt-neo-2_7B'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLanguageGenerationPost(text?: string, model?: 'EleutherAI-gpt-neo-2_7B', options?: any) {
            return TextTextLanguageGenerationApiFp(configuration).applyTextTextLanguageGenerationPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for language-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLanguageGenerationGet(options?: any) {
            return TextTextLanguageGenerationApiFp(configuration).getVersionsTextTextLanguageGenerationGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextLanguageGenerationApi - object-oriented interface
 * @export
 * @class TextTextLanguageGenerationApi
 * @extends {BaseAPI}
 */
export class TextTextLanguageGenerationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the language-generation task for a given models
     * @param {string} [text] 
     * @param {'EleutherAI-gpt-neo-2_7B'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextLanguageGenerationApi
     */
    public applyTextTextLanguageGenerationPost(text?: string, model?: 'EleutherAI-gpt-neo-2_7B', options?: any) {
        return TextTextLanguageGenerationApiFp(this.configuration).applyTextTextLanguageGenerationPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for language-generation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextLanguageGenerationApi
     */
    public getVersionsTextTextLanguageGenerationGet(options?: any) {
        return TextTextLanguageGenerationApiFp(this.configuration).getVersionsTextTextLanguageGenerationGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextLemmatizationApi - axios parameter creator
 * @export
 */
export const TextTextLemmatizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the lemmatization task for a given models
         * @param {string} [sentence] 
         * @param {'wordnet'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLemmatizationPost(sentence?: string, model?: 'wordnet', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/lemmatization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sentence !== undefined) {
                localVarQueryParameter['sentence'] = sentence;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for lemmatization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLemmatizationGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/lemmatization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextLemmatizationApi - functional programming interface
 * @export
 */
export const TextTextLemmatizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the lemmatization task for a given models
         * @param {string} [sentence] 
         * @param {'wordnet'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLemmatizationPost(sentence?: string, model?: 'wordnet', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextLemmatizationApiAxiosParamCreator(configuration).applyTextTextLemmatizationPost(sentence, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for lemmatization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLemmatizationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextLemmatizationApiAxiosParamCreator(configuration).getVersionsTextTextLemmatizationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextLemmatizationApi - factory interface
 * @export
 */
export const TextTextLemmatizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the lemmatization task for a given models
         * @param {string} [sentence] 
         * @param {'wordnet'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextLemmatizationPost(sentence?: string, model?: 'wordnet', options?: any) {
            return TextTextLemmatizationApiFp(configuration).applyTextTextLemmatizationPost(sentence, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for lemmatization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextLemmatizationGet(options?: any) {
            return TextTextLemmatizationApiFp(configuration).getVersionsTextTextLemmatizationGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextLemmatizationApi - object-oriented interface
 * @export
 * @class TextTextLemmatizationApi
 * @extends {BaseAPI}
 */
export class TextTextLemmatizationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the lemmatization task for a given models
     * @param {string} [sentence] 
     * @param {'wordnet'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextLemmatizationApi
     */
    public applyTextTextLemmatizationPost(sentence?: string, model?: 'wordnet', options?: any) {
        return TextTextLemmatizationApiFp(this.configuration).applyTextTextLemmatizationPost(sentence, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for lemmatization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextLemmatizationApi
     */
    public getVersionsTextTextLemmatizationGet(options?: any) {
        return TextTextLemmatizationApiFp(this.configuration).getVersionsTextTextLemmatizationGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextNamedEntityRecognitionApi - axios parameter creator
 * @export
 */
export const TextTextNamedEntityRecognitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the named-entity-recognition task for a given models
         * @param {string} [text] 
         * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNamedEntityRecognitionPost(text?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/named-entity-recognition/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for named-entity-recognition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNamedEntityRecognitionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/named-entity-recognition/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextNamedEntityRecognitionApi - functional programming interface
 * @export
 */
export const TextTextNamedEntityRecognitionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the named-entity-recognition task for a given models
         * @param {string} [text] 
         * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNamedEntityRecognitionPost(text?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextNamedEntityRecognitionApiAxiosParamCreator(configuration).applyTextTextNamedEntityRecognitionPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for named-entity-recognition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNamedEntityRecognitionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextNamedEntityRecognitionApiAxiosParamCreator(configuration).getVersionsTextTextNamedEntityRecognitionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextNamedEntityRecognitionApi - factory interface
 * @export
 */
export const TextTextNamedEntityRecognitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the named-entity-recognition task for a given models
         * @param {string} [text] 
         * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNamedEntityRecognitionPost(text?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options?: any) {
            return TextTextNamedEntityRecognitionApiFp(configuration).applyTextTextNamedEntityRecognitionPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for named-entity-recognition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNamedEntityRecognitionGet(options?: any) {
            return TextTextNamedEntityRecognitionApiFp(configuration).getVersionsTextTextNamedEntityRecognitionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextNamedEntityRecognitionApi - object-oriented interface
 * @export
 * @class TextTextNamedEntityRecognitionApi
 * @extends {BaseAPI}
 */
export class TextTextNamedEntityRecognitionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the named-entity-recognition task for a given models
     * @param {string} [text] 
     * @param {'dbmdz-bert-large-cased-finetuned-conll03-english'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextNamedEntityRecognitionApi
     */
    public applyTextTextNamedEntityRecognitionPost(text?: string, model?: 'dbmdz-bert-large-cased-finetuned-conll03-english', options?: any) {
        return TextTextNamedEntityRecognitionApiFp(this.configuration).applyTextTextNamedEntityRecognitionPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for named-entity-recognition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextNamedEntityRecognitionApi
     */
    public getVersionsTextTextNamedEntityRecognitionGet(options?: any) {
        return TextTextNamedEntityRecognitionApiFp(this.configuration).getVersionsTextTextNamedEntityRecognitionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextNextSentencePredictionApi - axios parameter creator
 * @export
 */
export const TextTextNextSentencePredictionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the next-sentence-prediction task for a given models
         * @param {string} [sentence1] 
         * @param {string} [sentence2] 
         * @param {'bert-base-uncased'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNextSentencePredictionPost(sentence1?: string, sentence2?: string, model?: 'bert-base-uncased', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/next-sentence-prediction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sentence1 !== undefined) {
                localVarQueryParameter['sentence_1'] = sentence1;
            }

            if (sentence2 !== undefined) {
                localVarQueryParameter['sentence_2'] = sentence2;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for next-sentence-prediction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNextSentencePredictionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/next-sentence-prediction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextNextSentencePredictionApi - functional programming interface
 * @export
 */
export const TextTextNextSentencePredictionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the next-sentence-prediction task for a given models
         * @param {string} [sentence1] 
         * @param {string} [sentence2] 
         * @param {'bert-base-uncased'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNextSentencePredictionPost(sentence1?: string, sentence2?: string, model?: 'bert-base-uncased', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextNextSentencePredictionApiAxiosParamCreator(configuration).applyTextTextNextSentencePredictionPost(sentence1, sentence2, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for next-sentence-prediction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNextSentencePredictionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextNextSentencePredictionApiAxiosParamCreator(configuration).getVersionsTextTextNextSentencePredictionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextNextSentencePredictionApi - factory interface
 * @export
 */
export const TextTextNextSentencePredictionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the next-sentence-prediction task for a given models
         * @param {string} [sentence1] 
         * @param {string} [sentence2] 
         * @param {'bert-base-uncased'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNextSentencePredictionPost(sentence1?: string, sentence2?: string, model?: 'bert-base-uncased', options?: any) {
            return TextTextNextSentencePredictionApiFp(configuration).applyTextTextNextSentencePredictionPost(sentence1, sentence2, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for next-sentence-prediction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNextSentencePredictionGet(options?: any) {
            return TextTextNextSentencePredictionApiFp(configuration).getVersionsTextTextNextSentencePredictionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextNextSentencePredictionApi - object-oriented interface
 * @export
 * @class TextTextNextSentencePredictionApi
 * @extends {BaseAPI}
 */
export class TextTextNextSentencePredictionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the next-sentence-prediction task for a given models
     * @param {string} [sentence1] 
     * @param {string} [sentence2] 
     * @param {'bert-base-uncased'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextNextSentencePredictionApi
     */
    public applyTextTextNextSentencePredictionPost(sentence1?: string, sentence2?: string, model?: 'bert-base-uncased', options?: any) {
        return TextTextNextSentencePredictionApiFp(this.configuration).applyTextTextNextSentencePredictionPost(sentence1, sentence2, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for next-sentence-prediction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextNextSentencePredictionApi
     */
    public getVersionsTextTextNextSentencePredictionGet(options?: any) {
        return TextTextNextSentencePredictionApiFp(this.configuration).getVersionsTextTextNextSentencePredictionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextNextWordPredictionApi - axios parameter creator
 * @export
 */
export const TextTextNextWordPredictionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the next-word-prediction task for a given models
         * @param {string} [sentence] 
         * @param {'bert-base-uncased' | 'roberta-base' | 'distilbert-base-uncased' | 'albert-base-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNextWordPredictionPost(sentence?: string, model?: 'bert-base-uncased' | 'roberta-base' | 'distilbert-base-uncased' | 'albert-base-v2', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/next-word-prediction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sentence !== undefined) {
                localVarQueryParameter['sentence'] = sentence;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for next-word-prediction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNextWordPredictionGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/next-word-prediction/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextNextWordPredictionApi - functional programming interface
 * @export
 */
export const TextTextNextWordPredictionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the next-word-prediction task for a given models
         * @param {string} [sentence] 
         * @param {'bert-base-uncased' | 'roberta-base' | 'distilbert-base-uncased' | 'albert-base-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNextWordPredictionPost(sentence?: string, model?: 'bert-base-uncased' | 'roberta-base' | 'distilbert-base-uncased' | 'albert-base-v2', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextNextWordPredictionApiAxiosParamCreator(configuration).applyTextTextNextWordPredictionPost(sentence, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for next-word-prediction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNextWordPredictionGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextNextWordPredictionApiAxiosParamCreator(configuration).getVersionsTextTextNextWordPredictionGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextNextWordPredictionApi - factory interface
 * @export
 */
export const TextTextNextWordPredictionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the next-word-prediction task for a given models
         * @param {string} [sentence] 
         * @param {'bert-base-uncased' | 'roberta-base' | 'distilbert-base-uncased' | 'albert-base-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextNextWordPredictionPost(sentence?: string, model?: 'bert-base-uncased' | 'roberta-base' | 'distilbert-base-uncased' | 'albert-base-v2', options?: any) {
            return TextTextNextWordPredictionApiFp(configuration).applyTextTextNextWordPredictionPost(sentence, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for next-word-prediction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextNextWordPredictionGet(options?: any) {
            return TextTextNextWordPredictionApiFp(configuration).getVersionsTextTextNextWordPredictionGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextNextWordPredictionApi - object-oriented interface
 * @export
 * @class TextTextNextWordPredictionApi
 * @extends {BaseAPI}
 */
export class TextTextNextWordPredictionApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the next-word-prediction task for a given models
     * @param {string} [sentence] 
     * @param {'bert-base-uncased' | 'roberta-base' | 'distilbert-base-uncased' | 'albert-base-v2'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextNextWordPredictionApi
     */
    public applyTextTextNextWordPredictionPost(sentence?: string, model?: 'bert-base-uncased' | 'roberta-base' | 'distilbert-base-uncased' | 'albert-base-v2', options?: any) {
        return TextTextNextWordPredictionApiFp(this.configuration).applyTextTextNextWordPredictionPost(sentence, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for next-word-prediction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextNextWordPredictionApi
     */
    public getVersionsTextTextNextWordPredictionGet(options?: any) {
        return TextTextNextWordPredictionApiFp(this.configuration).getVersionsTextTextNextWordPredictionGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextPluralApi - axios parameter creator
 * @export
 */
export const TextTextPluralApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the plural task for a given models
         * @param {string} [word] 
         * @param {number} [count] 
         * @param {'inflect'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextPluralPost(word?: string, count?: number, model?: 'inflect', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/plural/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (word !== undefined) {
                localVarQueryParameter['word'] = word;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for plural
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextPluralGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/plural/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextPluralApi - functional programming interface
 * @export
 */
export const TextTextPluralApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the plural task for a given models
         * @param {string} [word] 
         * @param {number} [count] 
         * @param {'inflect'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextPluralPost(word?: string, count?: number, model?: 'inflect', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextPluralApiAxiosParamCreator(configuration).applyTextTextPluralPost(word, count, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for plural
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextPluralGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextPluralApiAxiosParamCreator(configuration).getVersionsTextTextPluralGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextPluralApi - factory interface
 * @export
 */
export const TextTextPluralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the plural task for a given models
         * @param {string} [word] 
         * @param {number} [count] 
         * @param {'inflect'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextPluralPost(word?: string, count?: number, model?: 'inflect', options?: any) {
            return TextTextPluralApiFp(configuration).applyTextTextPluralPost(word, count, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for plural
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextPluralGet(options?: any) {
            return TextTextPluralApiFp(configuration).getVersionsTextTextPluralGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextPluralApi - object-oriented interface
 * @export
 * @class TextTextPluralApi
 * @extends {BaseAPI}
 */
export class TextTextPluralApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the plural task for a given models
     * @param {string} [word] 
     * @param {number} [count] 
     * @param {'inflect'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextPluralApi
     */
    public applyTextTextPluralPost(word?: string, count?: number, model?: 'inflect', options?: any) {
        return TextTextPluralApiFp(this.configuration).applyTextTextPluralPost(word, count, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for plural
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextPluralApi
     */
    public getVersionsTextTextPluralGet(options?: any) {
        return TextTextPluralApiFp(this.configuration).getVersionsTextTextPluralGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextProgrammingLanguageGenerationApi - axios parameter creator
 * @export
 */
export const TextTextProgrammingLanguageGenerationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the programming-language-generation task for a given models
         * @param {string} [codeSnippet] 
         * @param {'sentdex-GPyT'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextProgrammingLanguageGenerationPost(codeSnippet?: string, model?: 'sentdex-GPyT', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/programming-language-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (codeSnippet !== undefined) {
                localVarQueryParameter['code_snippet'] = codeSnippet;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for programming-language-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextProgrammingLanguageGenerationGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/programming-language-generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextProgrammingLanguageGenerationApi - functional programming interface
 * @export
 */
export const TextTextProgrammingLanguageGenerationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the programming-language-generation task for a given models
         * @param {string} [codeSnippet] 
         * @param {'sentdex-GPyT'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextProgrammingLanguageGenerationPost(codeSnippet?: string, model?: 'sentdex-GPyT', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextProgrammingLanguageGenerationApiAxiosParamCreator(configuration).applyTextTextProgrammingLanguageGenerationPost(codeSnippet, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for programming-language-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextProgrammingLanguageGenerationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextProgrammingLanguageGenerationApiAxiosParamCreator(configuration).getVersionsTextTextProgrammingLanguageGenerationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextProgrammingLanguageGenerationApi - factory interface
 * @export
 */
export const TextTextProgrammingLanguageGenerationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the programming-language-generation task for a given models
         * @param {string} [codeSnippet] 
         * @param {'sentdex-GPyT'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextProgrammingLanguageGenerationPost(codeSnippet?: string, model?: 'sentdex-GPyT', options?: any) {
            return TextTextProgrammingLanguageGenerationApiFp(configuration).applyTextTextProgrammingLanguageGenerationPost(codeSnippet, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for programming-language-generation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextProgrammingLanguageGenerationGet(options?: any) {
            return TextTextProgrammingLanguageGenerationApiFp(configuration).getVersionsTextTextProgrammingLanguageGenerationGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextProgrammingLanguageGenerationApi - object-oriented interface
 * @export
 * @class TextTextProgrammingLanguageGenerationApi
 * @extends {BaseAPI}
 */
export class TextTextProgrammingLanguageGenerationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the programming-language-generation task for a given models
     * @param {string} [codeSnippet] 
     * @param {'sentdex-GPyT'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextProgrammingLanguageGenerationApi
     */
    public applyTextTextProgrammingLanguageGenerationPost(codeSnippet?: string, model?: 'sentdex-GPyT', options?: any) {
        return TextTextProgrammingLanguageGenerationApiFp(this.configuration).applyTextTextProgrammingLanguageGenerationPost(codeSnippet, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for programming-language-generation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextProgrammingLanguageGenerationApi
     */
    public getVersionsTextTextProgrammingLanguageGenerationGet(options?: any) {
        return TextTextProgrammingLanguageGenerationApiFp(this.configuration).getVersionsTextTextProgrammingLanguageGenerationGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextProgrammingLanguageIdentificationApi - axios parameter creator
 * @export
 */
export const TextTextProgrammingLanguageIdentificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the programming-language-identification task for a given models
         * @param {string} [text] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextProgrammingLanguageIdentificationPost(text?: string, model?: string, options: any = {}): RequestArgs {
            const localVarPath = `/text/text/programming-language-identification/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for programming-language-identification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextProgrammingLanguageIdentificationGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/programming-language-identification/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextProgrammingLanguageIdentificationApi - functional programming interface
 * @export
 */
export const TextTextProgrammingLanguageIdentificationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the programming-language-identification task for a given models
         * @param {string} [text] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextProgrammingLanguageIdentificationPost(text?: string, model?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextProgrammingLanguageIdentificationApiAxiosParamCreator(configuration).applyTextTextProgrammingLanguageIdentificationPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for programming-language-identification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextProgrammingLanguageIdentificationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextProgrammingLanguageIdentificationApiAxiosParamCreator(configuration).getVersionsTextTextProgrammingLanguageIdentificationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextProgrammingLanguageIdentificationApi - factory interface
 * @export
 */
export const TextTextProgrammingLanguageIdentificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the programming-language-identification task for a given models
         * @param {string} [text] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextProgrammingLanguageIdentificationPost(text?: string, model?: string, options?: any) {
            return TextTextProgrammingLanguageIdentificationApiFp(configuration).applyTextTextProgrammingLanguageIdentificationPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for programming-language-identification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextProgrammingLanguageIdentificationGet(options?: any) {
            return TextTextProgrammingLanguageIdentificationApiFp(configuration).getVersionsTextTextProgrammingLanguageIdentificationGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextProgrammingLanguageIdentificationApi - object-oriented interface
 * @export
 * @class TextTextProgrammingLanguageIdentificationApi
 * @extends {BaseAPI}
 */
export class TextTextProgrammingLanguageIdentificationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the programming-language-identification task for a given models
     * @param {string} [text] 
     * @param {string} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextProgrammingLanguageIdentificationApi
     */
    public applyTextTextProgrammingLanguageIdentificationPost(text?: string, model?: string, options?: any) {
        return TextTextProgrammingLanguageIdentificationApiFp(this.configuration).applyTextTextProgrammingLanguageIdentificationPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for programming-language-identification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextProgrammingLanguageIdentificationApi
     */
    public getVersionsTextTextProgrammingLanguageIdentificationGet(options?: any) {
        return TextTextProgrammingLanguageIdentificationApiFp(this.configuration).getVersionsTextTextProgrammingLanguageIdentificationGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextQuestionAnsweringApi - axios parameter creator
 * @export
 */
export const TextTextQuestionAnsweringApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the question-answering task for a given models
         * @param {string} [context] 
         * @param {string} [question] 
         * @param {'deepset_bert-base-cased-squad2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'distilbert-base-cased-distilled-squad'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextQuestionAnsweringPost(context?: string, question?: string, model?: 'deepset_bert-base-cased-squad2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'distilbert-base-cased-distilled-squad', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/question-answering/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (question !== undefined) {
                localVarQueryParameter['question'] = question;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for question-answering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextQuestionAnsweringGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/question-answering/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextQuestionAnsweringApi - functional programming interface
 * @export
 */
export const TextTextQuestionAnsweringApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the question-answering task for a given models
         * @param {string} [context] 
         * @param {string} [question] 
         * @param {'deepset_bert-base-cased-squad2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'distilbert-base-cased-distilled-squad'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextQuestionAnsweringPost(context?: string, question?: string, model?: 'deepset_bert-base-cased-squad2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'distilbert-base-cased-distilled-squad', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextQuestionAnsweringApiAxiosParamCreator(configuration).applyTextTextQuestionAnsweringPost(context, question, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for question-answering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextQuestionAnsweringGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextQuestionAnsweringApiAxiosParamCreator(configuration).getVersionsTextTextQuestionAnsweringGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextQuestionAnsweringApi - factory interface
 * @export
 */
export const TextTextQuestionAnsweringApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the question-answering task for a given models
         * @param {string} [context] 
         * @param {string} [question] 
         * @param {'deepset_bert-base-cased-squad2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'distilbert-base-cased-distilled-squad'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextQuestionAnsweringPost(context?: string, question?: string, model?: 'deepset_bert-base-cased-squad2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'distilbert-base-cased-distilled-squad', options?: any) {
            return TextTextQuestionAnsweringApiFp(configuration).applyTextTextQuestionAnsweringPost(context, question, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for question-answering
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextQuestionAnsweringGet(options?: any) {
            return TextTextQuestionAnsweringApiFp(configuration).getVersionsTextTextQuestionAnsweringGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextQuestionAnsweringApi - object-oriented interface
 * @export
 * @class TextTextQuestionAnsweringApi
 * @extends {BaseAPI}
 */
export class TextTextQuestionAnsweringApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the question-answering task for a given models
     * @param {string} [context] 
     * @param {string} [question] 
     * @param {'deepset_bert-base-cased-squad2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'distilbert-base-cased-distilled-squad'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextQuestionAnsweringApi
     */
    public applyTextTextQuestionAnsweringPost(context?: string, question?: string, model?: 'deepset_bert-base-cased-squad2' | 'mfeb-albert-xxlarge-v2-squad2' | 'deepset-roberta-base-squad2' | 'mrm8488-bert-tiny-5-finetuned-squadv2' | 'distilbert-base-cased-distilled-squad', options?: any) {
        return TextTextQuestionAnsweringApiFp(this.configuration).applyTextTextQuestionAnsweringPost(context, question, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for question-answering
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextQuestionAnsweringApi
     */
    public getVersionsTextTextQuestionAnsweringGet(options?: any) {
        return TextTextQuestionAnsweringApiFp(this.configuration).getVersionsTextTextQuestionAnsweringGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextSentencePairModelingApi - axios parameter creator
 * @export
 */
export const TextTextSentencePairModelingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the sentence-pair-modeling task for a given models
         * @param {string} [sentence] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentencePairModelingPost(sentence?: string, model?: string, options: any = {}): RequestArgs {
            const localVarPath = `/text/text/sentence-pair-modeling/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sentence !== undefined) {
                localVarQueryParameter['sentence'] = sentence;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for sentence-pair-modeling
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentencePairModelingGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/sentence-pair-modeling/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextSentencePairModelingApi - functional programming interface
 * @export
 */
export const TextTextSentencePairModelingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the sentence-pair-modeling task for a given models
         * @param {string} [sentence] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentencePairModelingPost(sentence?: string, model?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSentencePairModelingApiAxiosParamCreator(configuration).applyTextTextSentencePairModelingPost(sentence, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for sentence-pair-modeling
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentencePairModelingGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSentencePairModelingApiAxiosParamCreator(configuration).getVersionsTextTextSentencePairModelingGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextSentencePairModelingApi - factory interface
 * @export
 */
export const TextTextSentencePairModelingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the sentence-pair-modeling task for a given models
         * @param {string} [sentence] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentencePairModelingPost(sentence?: string, model?: string, options?: any) {
            return TextTextSentencePairModelingApiFp(configuration).applyTextTextSentencePairModelingPost(sentence, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for sentence-pair-modeling
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentencePairModelingGet(options?: any) {
            return TextTextSentencePairModelingApiFp(configuration).getVersionsTextTextSentencePairModelingGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextSentencePairModelingApi - object-oriented interface
 * @export
 * @class TextTextSentencePairModelingApi
 * @extends {BaseAPI}
 */
export class TextTextSentencePairModelingApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the sentence-pair-modeling task for a given models
     * @param {string} [sentence] 
     * @param {string} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSentencePairModelingApi
     */
    public applyTextTextSentencePairModelingPost(sentence?: string, model?: string, options?: any) {
        return TextTextSentencePairModelingApiFp(this.configuration).applyTextTextSentencePairModelingPost(sentence, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for sentence-pair-modeling
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSentencePairModelingApi
     */
    public getVersionsTextTextSentencePairModelingGet(options?: any) {
        return TextTextSentencePairModelingApiFp(this.configuration).getVersionsTextTextSentencePairModelingGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextSentenceParaphraserApi - axios parameter creator
 * @export
 */
export const TextTextSentenceParaphraserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the sentence-paraphraser task for a given models
         * @param {string} [context] 
         * @param {'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentenceParaphraserPost(context?: string, model?: 'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/sentence-paraphraser/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for sentence-paraphraser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentenceParaphraserGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/sentence-paraphraser/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextSentenceParaphraserApi - functional programming interface
 * @export
 */
export const TextTextSentenceParaphraserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the sentence-paraphraser task for a given models
         * @param {string} [context] 
         * @param {'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentenceParaphraserPost(context?: string, model?: 'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSentenceParaphraserApiAxiosParamCreator(configuration).applyTextTextSentenceParaphraserPost(context, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for sentence-paraphraser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentenceParaphraserGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSentenceParaphraserApiAxiosParamCreator(configuration).getVersionsTextTextSentenceParaphraserGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextSentenceParaphraserApi - factory interface
 * @export
 */
export const TextTextSentenceParaphraserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the sentence-paraphraser task for a given models
         * @param {string} [context] 
         * @param {'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentenceParaphraserPost(context?: string, model?: 'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality', options?: any) {
            return TextTextSentenceParaphraserApiFp(configuration).applyTextTextSentenceParaphraserPost(context, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for sentence-paraphraser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentenceParaphraserGet(options?: any) {
            return TextTextSentenceParaphraserApiFp(configuration).getVersionsTextTextSentenceParaphraserGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextSentenceParaphraserApi - object-oriented interface
 * @export
 * @class TextTextSentenceParaphraserApi
 * @extends {BaseAPI}
 */
export class TextTextSentenceParaphraserApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the sentence-paraphraser task for a given models
     * @param {string} [context] 
     * @param {'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSentenceParaphraserApi
     */
    public applyTextTextSentenceParaphraserPost(context?: string, model?: 'ramsrigouthamg-t5-large-paraphraser-diverse-high-quality', options?: any) {
        return TextTextSentenceParaphraserApiFp(this.configuration).applyTextTextSentenceParaphraserPost(context, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for sentence-paraphraser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSentenceParaphraserApi
     */
    public getVersionsTextTextSentenceParaphraserGet(options?: any) {
        return TextTextSentenceParaphraserApiFp(this.configuration).getVersionsTextTextSentenceParaphraserGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextSentimentAnalysisApi - axios parameter creator
 * @export
 */
export const TextTextSentimentAnalysisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the sentiment-analysis task for a given models
         * @param {string} [text] 
         * @param {'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased' | 'distilbert-base-uncased-finetuned-sst-2-english' | 'zero-shot-classification-facebook-bart-large-mnli'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentimentAnalysisPost(text?: string, model?: 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased' | 'distilbert-base-uncased-finetuned-sst-2-english' | 'zero-shot-classification-facebook-bart-large-mnli', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/sentiment-analysis/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for sentiment-analysis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentimentAnalysisGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/sentiment-analysis/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextSentimentAnalysisApi - functional programming interface
 * @export
 */
export const TextTextSentimentAnalysisApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the sentiment-analysis task for a given models
         * @param {string} [text] 
         * @param {'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased' | 'distilbert-base-uncased-finetuned-sst-2-english' | 'zero-shot-classification-facebook-bart-large-mnli'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentimentAnalysisPost(text?: string, model?: 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased' | 'distilbert-base-uncased-finetuned-sst-2-english' | 'zero-shot-classification-facebook-bart-large-mnli', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSentimentAnalysisApiAxiosParamCreator(configuration).applyTextTextSentimentAnalysisPost(text, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for sentiment-analysis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentimentAnalysisGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSentimentAnalysisApiAxiosParamCreator(configuration).getVersionsTextTextSentimentAnalysisGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextSentimentAnalysisApi - factory interface
 * @export
 */
export const TextTextSentimentAnalysisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the sentiment-analysis task for a given models
         * @param {string} [text] 
         * @param {'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased' | 'distilbert-base-uncased-finetuned-sst-2-english' | 'zero-shot-classification-facebook-bart-large-mnli'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSentimentAnalysisPost(text?: string, model?: 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased' | 'distilbert-base-uncased-finetuned-sst-2-english' | 'zero-shot-classification-facebook-bart-large-mnli', options?: any) {
            return TextTextSentimentAnalysisApiFp(configuration).applyTextTextSentimentAnalysisPost(text, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for sentiment-analysis
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSentimentAnalysisGet(options?: any) {
            return TextTextSentimentAnalysisApiFp(configuration).getVersionsTextTextSentimentAnalysisGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextSentimentAnalysisApi - object-oriented interface
 * @export
 * @class TextTextSentimentAnalysisApi
 * @extends {BaseAPI}
 */
export class TextTextSentimentAnalysisApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the sentiment-analysis task for a given models
     * @param {string} [text] 
     * @param {'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased' | 'distilbert-base-uncased-finetuned-sst-2-english' | 'zero-shot-classification-facebook-bart-large-mnli'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSentimentAnalysisApi
     */
    public applyTextTextSentimentAnalysisPost(text?: string, model?: 'nlptown-bert-base-multilingual-uncased-sentiment' | 'distilbert-base-uncased' | 'distilbert-base-uncased-finetuned-sst-2-english' | 'zero-shot-classification-facebook-bart-large-mnli', options?: any) {
        return TextTextSentimentAnalysisApiFp(this.configuration).applyTextTextSentimentAnalysisPost(text, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for sentiment-analysis
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSentimentAnalysisApi
     */
    public getVersionsTextTextSentimentAnalysisGet(options?: any) {
        return TextTextSentimentAnalysisApiFp(this.configuration).getVersionsTextTextSentimentAnalysisGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextSimilarityApi - axios parameter creator
 * @export
 */
export const TextTextSimilarityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the similarity task for a given models
         * @param {string} [sentence1] 
         * @param {string} [sentence2] 
         * @param {'all-MiniLM-L6-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSimilarityPost(sentence1?: string, sentence2?: string, model?: 'all-MiniLM-L6-v2', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/similarity/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sentence1 !== undefined) {
                localVarQueryParameter['sentence_1'] = sentence1;
            }

            if (sentence2 !== undefined) {
                localVarQueryParameter['sentence_2'] = sentence2;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for similarity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSimilarityGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/similarity/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextSimilarityApi - functional programming interface
 * @export
 */
export const TextTextSimilarityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the similarity task for a given models
         * @param {string} [sentence1] 
         * @param {string} [sentence2] 
         * @param {'all-MiniLM-L6-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSimilarityPost(sentence1?: string, sentence2?: string, model?: 'all-MiniLM-L6-v2', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSimilarityApiAxiosParamCreator(configuration).applyTextTextSimilarityPost(sentence1, sentence2, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for similarity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSimilarityGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSimilarityApiAxiosParamCreator(configuration).getVersionsTextTextSimilarityGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextSimilarityApi - factory interface
 * @export
 */
export const TextTextSimilarityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the similarity task for a given models
         * @param {string} [sentence1] 
         * @param {string} [sentence2] 
         * @param {'all-MiniLM-L6-v2'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSimilarityPost(sentence1?: string, sentence2?: string, model?: 'all-MiniLM-L6-v2', options?: any) {
            return TextTextSimilarityApiFp(configuration).applyTextTextSimilarityPost(sentence1, sentence2, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for similarity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSimilarityGet(options?: any) {
            return TextTextSimilarityApiFp(configuration).getVersionsTextTextSimilarityGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextSimilarityApi - object-oriented interface
 * @export
 * @class TextTextSimilarityApi
 * @extends {BaseAPI}
 */
export class TextTextSimilarityApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the similarity task for a given models
     * @param {string} [sentence1] 
     * @param {string} [sentence2] 
     * @param {'all-MiniLM-L6-v2'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSimilarityApi
     */
    public applyTextTextSimilarityPost(sentence1?: string, sentence2?: string, model?: 'all-MiniLM-L6-v2', options?: any) {
        return TextTextSimilarityApiFp(this.configuration).applyTextTextSimilarityPost(sentence1, sentence2, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for similarity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSimilarityApi
     */
    public getVersionsTextTextSimilarityGet(options?: any) {
        return TextTextSimilarityApiFp(this.configuration).getVersionsTextTextSimilarityGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextSummarizationApi - axios parameter creator
 * @export
 */
export const TextTextSummarizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the summarization task for a given models
         * @param {string} [text] 
         * @param {string} [sourceLanguage] 
         * @param {number} [maxLength] 
         * @param {number} [minLength] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSummarizationPost(text?: string, sourceLanguage?: string, maxLength?: number, minLength?: number, model?: string, options: any = {}): RequestArgs {
            const localVarPath = `/text/text/summarization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (sourceLanguage !== undefined) {
                localVarQueryParameter['source_language'] = sourceLanguage;
            }

            if (maxLength !== undefined) {
                localVarQueryParameter['max_length'] = maxLength;
            }

            if (minLength !== undefined) {
                localVarQueryParameter['min_length'] = minLength;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for summarization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSummarizationGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/summarization/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextSummarizationApi - functional programming interface
 * @export
 */
export const TextTextSummarizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the summarization task for a given models
         * @param {string} [text] 
         * @param {string} [sourceLanguage] 
         * @param {number} [maxLength] 
         * @param {number} [minLength] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSummarizationPost(text?: string, sourceLanguage?: string, maxLength?: number, minLength?: number, model?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSummarizationApiAxiosParamCreator(configuration).applyTextTextSummarizationPost(text, sourceLanguage, maxLength, minLength, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for summarization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSummarizationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextSummarizationApiAxiosParamCreator(configuration).getVersionsTextTextSummarizationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextSummarizationApi - factory interface
 * @export
 */
export const TextTextSummarizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the summarization task for a given models
         * @param {string} [text] 
         * @param {string} [sourceLanguage] 
         * @param {number} [maxLength] 
         * @param {number} [minLength] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextSummarizationPost(text?: string, sourceLanguage?: string, maxLength?: number, minLength?: number, model?: string, options?: any) {
            return TextTextSummarizationApiFp(configuration).applyTextTextSummarizationPost(text, sourceLanguage, maxLength, minLength, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for summarization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextSummarizationGet(options?: any) {
            return TextTextSummarizationApiFp(configuration).getVersionsTextTextSummarizationGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextSummarizationApi - object-oriented interface
 * @export
 * @class TextTextSummarizationApi
 * @extends {BaseAPI}
 */
export class TextTextSummarizationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the summarization task for a given models
     * @param {string} [text] 
     * @param {string} [sourceLanguage] 
     * @param {number} [maxLength] 
     * @param {number} [minLength] 
     * @param {string} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSummarizationApi
     */
    public applyTextTextSummarizationPost(text?: string, sourceLanguage?: string, maxLength?: number, minLength?: number, model?: string, options?: any) {
        return TextTextSummarizationApiFp(this.configuration).applyTextTextSummarizationPost(text, sourceLanguage, maxLength, minLength, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for summarization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextSummarizationApi
     */
    public getVersionsTextTextSummarizationGet(options?: any) {
        return TextTextSummarizationApiFp(this.configuration).getVersionsTextTextSummarizationGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextTranslationApi - axios parameter creator
 * @export
 */
export const TextTextTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the translation task for a given models
         * @param {string} [inputString] 
         * @param {string} [sourceLanguage] 
         * @param {string} [targetLanguage] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextTranslationPost(inputString?: string, sourceLanguage?: string, targetLanguage?: string, model?: string, options: any = {}): RequestArgs {
            const localVarPath = `/text/text/translation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (inputString !== undefined) {
                localVarQueryParameter['input_string'] = inputString;
            }

            if (sourceLanguage !== undefined) {
                localVarQueryParameter['source_language'] = sourceLanguage;
            }

            if (targetLanguage !== undefined) {
                localVarQueryParameter['target_language'] = targetLanguage;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for translation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextTranslationGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/translation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextTranslationApi - functional programming interface
 * @export
 */
export const TextTextTranslationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the translation task for a given models
         * @param {string} [inputString] 
         * @param {string} [sourceLanguage] 
         * @param {string} [targetLanguage] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextTranslationPost(inputString?: string, sourceLanguage?: string, targetLanguage?: string, model?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextTranslationApiAxiosParamCreator(configuration).applyTextTextTranslationPost(inputString, sourceLanguage, targetLanguage, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for translation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextTranslationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextTranslationApiAxiosParamCreator(configuration).getVersionsTextTextTranslationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextTranslationApi - factory interface
 * @export
 */
export const TextTextTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the translation task for a given models
         * @param {string} [inputString] 
         * @param {string} [sourceLanguage] 
         * @param {string} [targetLanguage] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextTranslationPost(inputString?: string, sourceLanguage?: string, targetLanguage?: string, model?: string, options?: any) {
            return TextTextTranslationApiFp(configuration).applyTextTextTranslationPost(inputString, sourceLanguage, targetLanguage, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for translation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextTranslationGet(options?: any) {
            return TextTextTranslationApiFp(configuration).getVersionsTextTextTranslationGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextTranslationApi - object-oriented interface
 * @export
 * @class TextTextTranslationApi
 * @extends {BaseAPI}
 */
export class TextTextTranslationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the translation task for a given models
     * @param {string} [inputString] 
     * @param {string} [sourceLanguage] 
     * @param {string} [targetLanguage] 
     * @param {string} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextTranslationApi
     */
    public applyTextTextTranslationPost(inputString?: string, sourceLanguage?: string, targetLanguage?: string, model?: string, options?: any) {
        return TextTextTranslationApiFp(this.configuration).applyTextTextTranslationPost(inputString, sourceLanguage, targetLanguage, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for translation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextTranslationApi
     */
    public getVersionsTextTextTranslationGet(options?: any) {
        return TextTextTranslationApiFp(this.configuration).getVersionsTextTextTranslationGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextTransliterationApi - axios parameter creator
 * @export
 */
export const TextTextTransliterationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the transliteration task for a given models
         * @param {string} [text] 
         * @param {string} [language] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextTransliterationPost(text?: string, language?: string, model?: string, options: any = {}): RequestArgs {
            const localVarPath = `/text/text/transliteration/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for transliteration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextTransliterationGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/transliteration/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextTransliterationApi - functional programming interface
 * @export
 */
export const TextTextTransliterationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the transliteration task for a given models
         * @param {string} [text] 
         * @param {string} [language] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextTransliterationPost(text?: string, language?: string, model?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextTransliterationApiAxiosParamCreator(configuration).applyTextTextTransliterationPost(text, language, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for transliteration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextTransliterationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextTransliterationApiAxiosParamCreator(configuration).getVersionsTextTextTransliterationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextTransliterationApi - factory interface
 * @export
 */
export const TextTextTransliterationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the transliteration task for a given models
         * @param {string} [text] 
         * @param {string} [language] 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextTransliterationPost(text?: string, language?: string, model?: string, options?: any) {
            return TextTextTransliterationApiFp(configuration).applyTextTextTransliterationPost(text, language, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for transliteration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextTransliterationGet(options?: any) {
            return TextTextTransliterationApiFp(configuration).getVersionsTextTextTransliterationGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextTransliterationApi - object-oriented interface
 * @export
 * @class TextTextTransliterationApi
 * @extends {BaseAPI}
 */
export class TextTextTransliterationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the transliteration task for a given models
     * @param {string} [text] 
     * @param {string} [language] 
     * @param {string} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextTransliterationApi
     */
    public applyTextTextTransliterationPost(text?: string, language?: string, model?: string, options?: any) {
        return TextTextTransliterationApiFp(this.configuration).applyTextTextTransliterationPost(text, language, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for transliteration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextTransliterationApi
     */
    public getVersionsTextTextTransliterationGet(options?: any) {
        return TextTextTransliterationApiFp(this.configuration).getVersionsTextTextTransliterationGet(options)(this.axios, this.basePath);
    }

}


/**
 * TextTextWordAlignmentApi - axios parameter creator
 * @export
 */
export const TextTextWordAlignmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the word-alignment task for a given models
         * @param {string} [inputStringLanguage1] 
         * @param {string} [inputStringLanguage2] 
         * @param {'bert-base-multilingual-cased'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextWordAlignmentPost(inputStringLanguage1?: string, inputStringLanguage2?: string, model?: 'bert-base-multilingual-cased', options: any = {}): RequestArgs {
            const localVarPath = `/text/text/word-alignment/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (inputStringLanguage1 !== undefined) {
                localVarQueryParameter['input_string_language_1'] = inputStringLanguage1;
            }

            if (inputStringLanguage2 !== undefined) {
                localVarQueryParameter['input_string_language_2'] = inputStringLanguage2;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for word-alignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextWordAlignmentGet(options: any = {}): RequestArgs {
            const localVarPath = `/text/text/word-alignment/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTextWordAlignmentApi - functional programming interface
 * @export
 */
export const TextTextWordAlignmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the word-alignment task for a given models
         * @param {string} [inputStringLanguage1] 
         * @param {string} [inputStringLanguage2] 
         * @param {'bert-base-multilingual-cased'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextWordAlignmentPost(inputStringLanguage1?: string, inputStringLanguage2?: string, model?: 'bert-base-multilingual-cased', options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextWordAlignmentApiAxiosParamCreator(configuration).applyTextTextWordAlignmentPost(inputStringLanguage1, inputStringLanguage2, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for word-alignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextWordAlignmentGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = TextTextWordAlignmentApiAxiosParamCreator(configuration).getVersionsTextTextWordAlignmentGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TextTextWordAlignmentApi - factory interface
 * @export
 */
export const TextTextWordAlignmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the word-alignment task for a given models
         * @param {string} [inputStringLanguage1] 
         * @param {string} [inputStringLanguage2] 
         * @param {'bert-base-multilingual-cased'} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyTextTextWordAlignmentPost(inputStringLanguage1?: string, inputStringLanguage2?: string, model?: 'bert-base-multilingual-cased', options?: any) {
            return TextTextWordAlignmentApiFp(configuration).applyTextTextWordAlignmentPost(inputStringLanguage1, inputStringLanguage2, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for word-alignment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsTextTextWordAlignmentGet(options?: any) {
            return TextTextWordAlignmentApiFp(configuration).getVersionsTextTextWordAlignmentGet(options)(axios, basePath);
        },
    };
};

/**
 * TextTextWordAlignmentApi - object-oriented interface
 * @export
 * @class TextTextWordAlignmentApi
 * @extends {BaseAPI}
 */
export class TextTextWordAlignmentApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the word-alignment task for a given models
     * @param {string} [inputStringLanguage1] 
     * @param {string} [inputStringLanguage2] 
     * @param {'bert-base-multilingual-cased'} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextWordAlignmentApi
     */
    public applyTextTextWordAlignmentPost(inputStringLanguage1?: string, inputStringLanguage2?: string, model?: 'bert-base-multilingual-cased', options?: any) {
        return TextTextWordAlignmentApiFp(this.configuration).applyTextTextWordAlignmentPost(inputStringLanguage1, inputStringLanguage2, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for word-alignment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTextWordAlignmentApi
     */
    public getVersionsTextTextWordAlignmentGet(options?: any) {
        return TextTextWordAlignmentApiFp(this.configuration).getVersionsTextTextWordAlignmentGet(options)(this.axios, this.basePath);
    }

}


/**
 * VideoVideoFrameInterpolationApi - axios parameter creator
 * @export
 */
export const VideoVideoFrameInterpolationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the frame-interpolation task for a given models
         * @param {any} video 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyVideoVideoFrameInterpolationPost(video: any, model?: string, options: any = {}): RequestArgs {
            // verify required parameter 'video' is not null or undefined
            if (video === null || video === undefined) {
                throw new RequiredError('video','Required parameter video was null or undefined when calling applyVideoVideoFrameInterpolationPost.');
            }
            const localVarPath = `/video/video/frame-interpolation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }


            if (video !== undefined) { 
                localVarFormParams.append('video', video as any);
            }
    
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of models available for frame-interpolation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsVideoVideoFrameInterpolationGet(options: any = {}): RequestArgs {
            const localVarPath = `/video/video/frame-interpolation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


                localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideoVideoFrameInterpolationApi - functional programming interface
 * @export
 */
export const VideoVideoFrameInterpolationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Apply model for the frame-interpolation task for a given models
         * @param {any} video 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyVideoVideoFrameInterpolationPost(video: any, model?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = VideoVideoFrameInterpolationApiAxiosParamCreator(configuration).applyVideoVideoFrameInterpolationPost(video, model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get list of models available for frame-interpolation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsVideoVideoFrameInterpolationGet(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object> {
            const localVarAxiosArgs = VideoVideoFrameInterpolationApiAxiosParamCreator(configuration).getVersionsVideoVideoFrameInterpolationGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VideoVideoFrameInterpolationApi - factory interface
 * @export
 */
export const VideoVideoFrameInterpolationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Apply model for the frame-interpolation task for a given models
         * @param {any} video 
         * @param {string} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyVideoVideoFrameInterpolationPost(video: any, model?: string, options?: any) {
            return VideoVideoFrameInterpolationApiFp(configuration).applyVideoVideoFrameInterpolationPost(video, model, options)(axios, basePath);
        },
        /**
         * 
         * @summary Get list of models available for frame-interpolation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionsVideoVideoFrameInterpolationGet(options?: any) {
            return VideoVideoFrameInterpolationApiFp(configuration).getVersionsVideoVideoFrameInterpolationGet(options)(axios, basePath);
        },
    };
};

/**
 * VideoVideoFrameInterpolationApi - object-oriented interface
 * @export
 * @class VideoVideoFrameInterpolationApi
 * @extends {BaseAPI}
 */
export class VideoVideoFrameInterpolationApi extends BaseAPI {
    /**
     * 
     * @summary Apply model for the frame-interpolation task for a given models
     * @param {any} video 
     * @param {string} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoVideoFrameInterpolationApi
     */
    public applyVideoVideoFrameInterpolationPost(video: any, model?: string, options?: any) {
        return VideoVideoFrameInterpolationApiFp(this.configuration).applyVideoVideoFrameInterpolationPost(video, model, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Get list of models available for frame-interpolation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoVideoFrameInterpolationApi
     */
    public getVersionsVideoVideoFrameInterpolationGet(options?: any) {
        return VideoVideoFrameInterpolationApiFp(this.configuration).getVersionsVideoVideoFrameInterpolationGet(options)(this.axios, this.basePath);
    }

}


